НАПИСАНИЕ СПЕЦИФИКАЦИИ

Мы напишем веб-приложение с именем Learning Log, при помощи которого пользователь сможет вести журнал интересующих его
тем и создавать записи в журнале во время изучения каждой темы. Домашняя страница Learning Log содержит описание сайта
и приглашает пользователя зарегистрироваться либо ввести свои учетные данные. После успешного входа пользователь
получает возможность создавать новые темы, добавлять новые записи, читать и редактировать существующие записи.

СОЗДАНИЕ ВИРТУАЛЬНОЙ СРЕДЫ

Для работы с Django необходимо сначала создать виртуальную среду для работы. Виртуальная среда представляет собой
подраздел системы, в котором вы можете устанавливать пакеты в изоляции от всех остальных пакетов Python. Отделение
библиотек одного проекта от других проектов принесет пользу при развертывании Learning Log на сервере в главе 20.
Создайте для проекта новый каталог с именем learning_log, перейдите в этот каталог в терминальном режиме и создайте
виртуальную среду следующими командами:
learning_log$ python -m venv ll_env
learning_log$
Команда запускает модуль виртуальной среды venv и использует его для создания виртуальной среды с именем ll_env
(обратите внимание: в имени ll_env две буквы l, а не одна). Если для запуска программ или установки пакетов
используется другая команда (например, python3), подставьте ее на место python.

АКТИВИЗАЦИЯ ВИРТУАЛЬНОЙ СРЕДЫ

После того как виртуальная среда будет создана, ее необходимо активизировать следующей командой:
learning_log$ source ll_env/bin/activate
❶ (ll_env)learning_log$
Команда запускает сценарий activate из каталога ll_env/bin. Когда среда активизируется, ее имя выводится в круглых
скобках ; теперь вы можете устанавливать пакеты в среде и использовать те пакеты, что были установлены ранее. Пакеты,
установленные в ll_env, будут доступны только в то время, пока среда остается активной.
ПРИМЕЧАНИЕ Если вы работаете в системе Windows, используйте команду ll_env\Scripts\activate (без слова source) для
активизации виртуальной среды. Если вы используете PowerShell, слово Activate должно начинаться с буквы верхнего регистра.
Чтобы завершить использование виртуальной среды, введите команду deactivate:
(ll_env)learning_log$ deactivate
learning_log$
Среда также становится неактивной при закрытии терминального окна, в котором она работает.

УСТАНОВКА DJANGO

После того как вы создали свою виртуальную среду и активизировали ее, установите Django:
(ll_env)learning_log$ pip install django
Collecting django
...
Installing collected packages: pytz, django
Successfully installed django-2.2.0 pytz-2018.9 sqlparse-0.2.4
(ll_env)learning_log$
Так как вы работаете в виртуальной среде, эта команда выглядит одинаково во всех системах. Использовать флаг --user
не нужно, как и использовать более длинные команды вида python -m pip install имя_пакета.
Помните, что с Django можно работать только в то время, пока среда остается активной.
ПРИМЕЧАНИЕ Новая версия Django выходит приблизительно раз в восемь месяцев; возможно, при установке Django будет
выведен новый номер версии. Скорее всего, проект будет работать в том виде, в каком он здесь приведен, даже в новых
версиях Django. Если вы хотите использовать ту же версию Django, которая используется здесь, введите команду
pip install django==2.2.*. Команда установит последний выпуск Django 2.2. Если у вас возникнут проблемы, связанные
с версией, обращайтесь к электронным ресурсам книги по адресу https://nostarch.com/pythoncrashcourse2e/.
Создание проекта в Django
Не выходя из активной виртуальной среды (пока ll_env выводится в круглых скобках), введите следующие команды для
создания нового проекта:
❶ (ll_env)learning_log$ django-admin.py startproject learning_log . (с точкой)
❷ (ll_env)learning_log$ ls
learning_log ll_env manage.py
❸ (ll_env)learning_log$ ls learning_log
__init__.py settings.py urls.py wsgi.py
Команда  приказывает Django создать новый проект с именем learning_log. Точка в конце команды создает новый проект
со структурой каталогов, которая упрощает развертывание приложения на сервере после завершения разработки.
Команда ls (dir в Windows)  показывает, что Django создает новый каталог с именем learning_log. Также создается файл manage.py — короткая программа, которая получает команды и передает их соответствующей части Django для выполнения. Мы используем эти команды для управления такими задачами, как работа с базами данных и запуск серверов.
В каталоге learning_log находятся четыре файла , важнейшими из которых являются файлы settings.py, urls.py и wsgi.py. Файл settings.py определяет то, как Django взаимодействует с вашей системой и управляет вашим проектом. Мы изменим некоторые из существующих настроек и добавим несколько новых настроек в ходе разработки проекта. Файл urls.py сообщает Django, какие страницы следует строить в ответ на запросы браузера. Файл wsgi.py помогает Django предоставлять созданные файлы (имя файла является сокращением от «Web Server Gateway Interface»).

СОЗДАНИЕ БАЗЫ ДАННЫХ

Так как Django хранит большую часть информации в базе данных, относящейся к проекту, на следующем этапе необходимо создать базу данных, с которой Django сможет работать. Введите следующую команду (все еще не покидая активную среду):
(ll_env)learning_log$ python manage.py migrate
❶ Operations to perform:
Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
Applying contenttypes.0001_initial... OK
Applying auth.0001_initial... OK
...
Applying sessions.0001_initial... OK
❷ (ll_env)learning_log$ ls
db.sqlite3 learning_log ll_env manage.py
Каждое изменение базы данных называется миграцией. Первое выполнение команды migrate приказывает Django проверить, что база данных соответствует текущему состоянию проекта. Когда мы впервые выполняем эту команду в новом проекте с использованием SQLite (вскоре мы расскажем о SQLite более подробно), Django создает новую базу данных за нас. В точке  Django сообщает о создании и подготовке базы данных к хранению информации, необходимой для выполнения административных операций и аутентификации.
Выполнение команды ls показывает, что Django создает другой файл с именем db.sqlite3 . SQLite — база данных, работающая с одним файлом; она идеально
подходит для написания простых приложений, потому что вам не нужно особенно следить за управлением базой данных.
ПРИМЕЧАНИЕ В активной виртуальной среде для выполнения команд manage.py используется команда python, даже если для запуска других программ вы используете другую команду (например, python3). В виртуальной среде команда python относится к версии Python, создавшей виртуальную среду.

ПРОСМОТР ПРОЕКТА

Убедимся в том, что проект был создан правильно. Введите команду runserver для просмотра текущего состояния проекта:
(ll_env)learning_log$ python manage.py runserver
Watchman unavailable: pywatchman not installed.
Watching for file changes with StatReloader
Performing system checks...
❶ System check identified no issues (0 silenced).
February 18, 2019 - 16:26:07
❷ Django version 2.2.0, using settings 'learning_log.settings'
❸ Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
Django запускает сервер, называемый сервером разработки, чтобы вы могли просмотреть проект в своей системе и проверить, как он работает. Когда вы запрашиваете страницу, вводя URL в браузере, сервер Django отвечает на запрос; для этого он строит соответствующую страницу и отправляет страницу браузеру.
В точке  Django проверяет правильность созданного проекта; в точке  выводится версия Django и имя используемого файла настроек; в точке  возвращается URL-адрес, по которому доступен проект. URL http://127.0.0.1:8000/ означает, что проект ведет прослушивание запросов на порте 8000 локального хоста (localhost), то есть вашего компьютера. Термином «локальный хост» обозначается сервер, который обрабатывает только запросы вашей системы; он не позволяет никому другому просмотреть разрабатываемые страницы.
Теперь откройте браузер и введите URL http://localhost:8000/ — или http://127.0.0.1:8000/, если первый адрес не работает. Вы увидите нечто похожее на рис. 18.1 — страницу, которую создает Django, чтобы сообщить вам, что все пока работает правильно. Пока не завершайте работу сервера (но когда вы захотите прервать ее, это можно сделать нажатием клавиш Ctrl+C в терминале, в котором была введена команда runserver).
ПРИМЕЧАНИЕ Если вы получаете сообщение об ошибке «Порт уже используется», прикажите Django использовать другой порт; для этого введите команду python manage.py runserver 8001 и продолжайте перебирать номера портов по возрастанию, пока не найдете открытый порт.

НАЧАЛО РАБОТЫ НАД ПРИЛОЖЕНИЕМ

Проект Django представляет собой группу отдельных приложений, совместная работа которых обеспечивает работу проекта в целом. Пока мы создадим одно приложение, которое будет выполнять большую часть работы в нашем проекте. Другое приложение для управления учетными записями пользователей будет добавлено в главе 19.
Оставьте сервер разработки выполняться в терминальном окне, открытом ранее. Откройте новое терминальное окно (или вкладку) и перейдите в каталог, содержащий manage.py. Активизируйте виртуальную среду и выполните команду startapp:
learning_log$ source ll_env/bin/activate
(ll_env)learning_log$ python manage.py startapp learning_logs
❶ (ll_env)learning_log$ ls
db.sqlite3 learning_log learning_logs ll_env manage.py
❷ (ll_env)learning_log$ ls learning_logs/
admin.py __init__.py migrations models.py tests.py views.py
Команда startapp имя_приложения приказывает Django создать инфраструктуру, необходимую для построения приложения. Заглянув сейчас в каталог проекта, вы найдете в нем новый подкаталог с именем learning_logs . Откройте этот каталог, чтобы увидеть, какие файлы были созданы Django . Самые важные файлы в этом каталоге — models.py, admin.py и views.py. Файл models.py будет использоваться для определения данных, которыми нужно управлять в нашем приложении. К файлам admin.py и views.py мы вернемся позднее.
Определение моделей
Подумаем, какие данные нам понадобятся. Каждый пользователь создает набор тем в своем журнале. Каждая запись, которую он сделает, будет привязана к определенной теме, а записи будут выводиться в текстовом виде. Также необходимо хранить временную метку каждой записи, чтобы пользователь знал, когда эта запись была создана.
Откройте файл models.py и просмотрите его текущее содержимое:
models.py
from django.db import models
# Создайте здесь свои модели.
Модуль с именем models импортируется автоматически, и нам предлагается создать свои модели. Модель сообщает Django, как работать с данными, которые будут храниться в приложении. С точки зрения кода модель представляет собой обычный класс; она содержит атрибуты и методы, как и все остальные классы, рассматривавшиеся нами ранее. Вот как выглядит модель тем обсуждения, которые будут сохраняться пользователями:
from django.db import models
class Topic(models.Model):
"""Тема, которую изучает пользователь"""
❶ text = models.CharField(max_length=200)
❷ date_added = models.DateTimeField(auto_now_add=True)
❸ def __str__(self):
"""Возвращает строковое представление модели."""
return self.text
Мы создали класс с именем Topic, наследующий от Model — родительского класса, включенного в Django и определяющего базовую функциональность модели. В класс Topic добавляются два атрибута: text и date_added.
Атрибут text содержит данные CharField — блок данных, состоящий из символов, то есть текст . Атрибуты CharField могут использоваться для хранения небольших объемов текста: имен, заголовков, названий городов и т. д. При определении атрибута CharField необходимо сообщить Django, сколько места нужно зарезервировать для него в базе данных. В данном случае задается максимальная длина max_length, равная 200 символам; этого должно быть достаточно для хранения большинства имен тем.
Атрибут date_added содержит данные DateTimeField — блок данных для хранения даты и времени . Аргумент auto_add_now=True приказывает Django автоматически присвоить этому атрибуту текущую дату и время каждый раз, когда пользователь создает новую тему.
ПРИМЕЧАНИЕ Полный список всех полей, которые могут использоваться в модели, приведены в документе Django Model Field Reference на https://docs.djangoproject.com/en/2.2/ref/models/fields/. Возможно, вся эта информация вам сейчас не понадобится, но она будет в высшей степени полезной, когда вы начнете разрабатывать собственные приложения.
Необходимо сообщить Django, какой атрибут должен использоваться по умолчанию при вводе информации о теме. Django вызывает метод __str__() для вывода простого представления модели. Мы написали реализацию __str__(), которая возвращает строку, хранящуюся в атрибуте text .
Активизация моделей
Чтобы использовать модели, необходимо приказать Django включить приложение в общий проект. Откройте файл settings.py (из каталога learning_log/learning_log) и найдите в нем раздел, который сообщает Django, какие приложения установлены в проекте:
settings.py
...
INSTALLED_APPS = (
'django.contrib.admin',
'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.messages',
'django.contrib.staticfiles',
)
...
Добавьте наше приложение в этот кортеж; измените содержимое INSTALLED_APPS, чтобы оно выглядело так:
...
INSTALLED_APPS = (
# Мои приложения
'learning_logs',
# Приложения django по умолчанию.
'django.contrib.admin',
...
]
...
Группировка приложений в проекте упрощает управление ими по мере того, как проект растет, а количество приложений увеличивается. Здесь мы создаем раздел, который пока содержит только приложение learning_logs. Очень важно разместить свои приложения перед приложениями по умолчанию на случай, если вам понадобится переопределить поведение таких приложений.
Затем необходимо приказать Django изменить базу данных для хранения информации, относящейся к модели Topic. В терминальном окне введите следующую команду:
(ll_env)learning_log$ python manage.py makemigrations learning_logs
Migrations for 'learning_logs':
learning_logs/migrations/0001_initial.py
- Create model Topic
(ll_env)learning_log$
По команде makemigrations Django определяет, как изменить базу данных для хранения информации, связанной с новыми моделями. Из результатов видно, что Django создает файл миграции с именем 0001_initial.py. Эта миграция создает в базе данных таблицу для модели Topic.
Теперь применим миграцию для автоматического изменения базы данных:
(ll_env)learning_log$ python manage.py migrate
Operations to perform:
Apply all migrations: admin, auth, contenttypes, learning_logs, sessions
Running migrations:
❶ Applying learning_logs.0001_initial... OK
Большая часть вывода этой команды совпадает с выводом, полученным при первом выполнении команды migrate. Обратить внимание следует на строку ; здесь Django подтверждает, что применение миграции для learning_logs прошло успешно.
Каждый раз, когда вы захотите изменить данные, которыми управляет Learning Log, выполните эти три действия: внесите изменения в models.py, вызовите makemigrations для learning_logs и прикажите Django выполнить миграцию проекта (migrate).

АДМИНИСТРАТИВНЫЙ САЙТ DJANGO

Django позволяет легко работать с моделями, определенными для приложения, через административный сайт. Этот сайт используется администраторами сайта,
а не рядовыми пользователями. В этом разделе мы создадим административный сайт и используем его для добавления некоторых тем через модель Topic.

СОЗДАНИЕ СУПЕРПОЛЬЗОВАТЕЛЯ

Django позволяет создать пользователя, обладающего полным набором привилегий на сайте; такой пользователь называется
суперпользователем. Привилегии управляют действиями, которые разрешено выполнять пользователю. На самом жестком уровне
привилегий пользователь может только читать общедоступную информацию на сайте. Зарегистрированным пользователям обычно
предоставляется привилегия чтения своих приватных данных, а также избранной информации, доступной только для участников
сообщества. Для эффективного администрирования веб-приложения владельцу сайта обычно должна быть доступна вся
информация, хранящаяся на сайте. Хороший администратор внимательно относится к конфиденциальной информации пользователя,
потому что пользователи доверяют тем приложениям, с которыми они работают.
Чтобы создать суперпользователя в Django, введите следующую команду и ответьте на запросы:
(ll_env)learning_log$ python manage.py createsuperuser
❶ Username (leave blank to use 'eric'): ll_admin
❷ Email address:
❸ Password:
Password (again):
Superuser created successfully.
(ll_env)learning_log$
При получении команды createsuperuser Django предлагает ввести имя пользователя, который является суперпользователем .
Здесь мы вводим имя ll_admin, но вы можете ввести любое имя на свое усмотрение. Также можно ввести адрес электронной
почты или оставить это поле пустым . После этого следует дважды ввести пароль .
ПРИМЕЧАНИЕ Часть конфиденциальной информации может быть скрыта от администраторов сайта. Например, Django на самом деле
не сохраняет введенный пароль; вместо этого сохраняется хеш — специальная строка, построенная на основе пароля. И когда
в будущем вы вводите пароль, Django снова хеширует введенные данные и сравнивает результат с хранимым хешем. Если два
хеша совпадают, то проверка пройдена. Если же хакер в результате атаки получит доступ к базе данных сайта, то он сможет
прочитать только хранящийся в базе хеш, но не пароли. При правильной настройке сайта восстановить исходные пароли из
хешей почти невозможно.

РЕГИСТРАЦИЯ МОДЕЛИ НА АДМИНИСТРАТИВНОМ САЙТЕ

Django добавляет некоторые модели (например, User и Group) на административный сайт автоматически, но модели, которые мы
создали, придется регистрировать вручную.
При запуске приложения learning_logs Django создает файл admin.py в одном каталоге с models.py. Откройте файл admin.py:
admin.py
from django.contrib import admin
# Зарегистрируйте здесь ваши модели.
Чтобы зарегистрировать Topic на административном сайте, введите следующую команду:
from django.contrib import admin
❶ from .models import Topic
❷ admin.site.register(Topic)
Этот код импортирует регистрируемую модель Topic . Точка перед models сообщает Django, что файл models.py следует искать в одном каталоге с admin.py. Вызов admin.site.register() сообщает Django, что управление моделью должно осуществляться через административный сайт .
Теперь используйте учетную запись суперпользователя для входа на административный сайт. Введите адрес http://localhost:8000/admin/, затем имя пользователя и пароль для только что созданного суперпользователя, и вы увидите экран наподобие изображенного на рис. 18.2. На этой странице можно добавлять новых пользователей и группы, а также вносить изменения в уже существующие настройки. Также можно работать с данными, связанными с только что определенной моделью Topic.

ДОБАВЛЕНИЕ ТЕМ

Когда модель Topic была зарегистрирована на административном сайте, добавим первую тему. Щелкните на ссылке Topics, чтобы перейти к странице Topics; страница практически пуста, потому что еще нет ни одной темы для выполнения операций. Щелкните на ссылке Add Topic; открывается форма для добавления новой темы. Введите в первом поле текст Chess и щелкните на ссылке Save. Вы возвращаетесь к административной странице Topics, на которой появляется только что созданная тема.
Создадим вторую тему, чтобы у вас было больше данных для работы. Снова щелкните на ссылке Add Topic и создайте вторую тему Rock Climbing. Ссылка Save снова возвращает вас к основной странице Topics, где отображаются обе темы, Chess и Rock Climbing.
Определение модели Entry
Чтобы сохранить информацию о том, что вы узнали по этим двум темам, необходимо определить модель для записей, которые пользователь делает в своих журналах. Каждая запись должна ассоциироваться с конкретной темой. Такое отношение называется отношением «многие к одному», поскольку многие записи могут быть связаны с одной темой.
Код модели Entry (из файла models.py) выглядит так:
models.py
from django.db import models
class Topic(models.Model):
...
❶ class Entry(models.Model):
"""Информация, изученная пользователем по теме"""
❷ topic = models.ForeignKey(Topic, on_delete=models.CASCADE)
❸ text = models.TextField()
date_added = models.DateTimeField(auto_now_add=True)
❹ class Meta:
verbose_name_plural = 'entries'
def __str__(self):
"""Возвращает строковое представление модели."""
❺ return f"{self.text[:50]}..."
Класс Entry наследует от базового класса Model, как и рассмотренный ранее класс Topic . Первый атрибут, topic, является экземпляром ForeignKey . Термин внешний ключ (foreign key) происходит из теории баз данных; внешний ключ содержит ссылку на другую запись в базе данных. Таким образом каждая запись связывается с конкретной темой. Каждой теме при создании присваивается ключ, или идентификатор. Если потребуется установить связь между двумя записями данных, Django использует ключ, связанный с каждым блоком информации. Вскоре мы используем такие связи для получения всех записей, связанных с заданной темой. Аргумент on_delete=models.CASCADE сообщает Django, что при удалении темы все записи, связанные с этой темой, также должны быть удалены (это называется каскадным удалением).
Затем идет атрибут с именем text, который является экземпляром TextField . Полю такого типа ограничение размера не требуется, потому что размер отдельных записей не ограничивается. Атрибут date_added позволяет отображать записи в порядке их создания и снабжать каждую запись временной меткой.
В точке  класс Meta вкладывается в класс Entry. Класс Meta хранит дополнительную информацию по управлению моделью; в данном случае он позволяет задать специальный атрибут, который приказывает Django использовать форму множественного числа Entries при обращении более чем к одной записи. (Без этого Django будет использовать неправильную форму Entrys.)
Метод __str__() сообщает Django, какая информация должна отображаться при обращении к отдельным записям. Так как запись может быть достаточно длинным блоком текста, мы приказываем Django выводить только первые 50 символов . Также добавляется многоточие — признак вывода неполного текста.

МИГРАЦИЯ МОДЕЛИ ENTRY

Так как мы добавили новую модель, миграцию базы данных необходимо провести снова. Вскоре вы привыкнете к этому процессу: вы изменяете models.py, выполняете команду python manage.py makemigrations имя_приложения, а затем команду python manage.py migrate.
Проведите миграцию базы данных и проверьте вывод:
(ll_env)learning_log$ python manage.py makemigrations learning_logs
Migrations for 'learning_logs':
❶ learning_logs/migrations/0002_entry.py
- Create model Entry
(ll_env)learning_log$ python manage.py migrate
Operations to perform:
...
❷ Applying learning_logs.0002_entry... OK
Команда генерирует новую миграцию с именем 0002_entry.py, которая сообщает Django, как изменить базу данных для хранения информации, связанной с моделью
Entry . При выдаче команды migrate Django подтверждает, что применение миграции прошло успешно .

РЕГИСТРАЦИЯ ENTRY НА АДМИНИСТРАТИВНОМ САЙТЕ

Модель Entry тоже необходимо зарегистрировать. Файл admin.py должен выглядеть так:
admin.py
from django.contrib import admin
from .models import Topic, Entry
admin.site.register(Topic)
admin.site.register(Entry)
Вернитесь на страницу http://localhost/admin/, и вы увидите раздел Entries в категории learning_logs. Щелкните на ссылке Add для Entries или щелкните на Entries и выберите вариант Add. На экране появляется раскрывающийся список для выбора темы, для которой создается запись, и текстовое поле для ввода записи. Выберите в раскрывающемся списке вариант Chess и добавьте запись.
При выборе ссылки Save вы вернетесь к основной административной странице. Здесь проявляются преимущества использования формата text[:50] в качестве строкового представления каждой записи; работать с несколькими записями в административном интерфейсе намного удобнее, если вы видите только часть записи вместо ее полного текста.
Создайте вторую запись для темы Chess и одну запись для темы Rock Climbing, чтобы у нас были исходные данные для дальнейшей разработки Learning Log.
Интерактивная оболочка Django
Введенные данные можно проанализировать на программном уровне в интерактивном терминальном сеансе. Эта интерактивная среда, называемая оболочкой (shell) Django, прекрасно подходит для тестирования и диагностики проекта. Пример сеанса в интерактивной оболочке:
(ll_env)learning_log$ python manage.py shell
❶ >>> from learning_logs.models import Topic
>>> Topic.objects.all()
<QuerySet [<Topic: Chess>, <Topic: Rock Climbing>]>
Команда python manage.py shell (выполняемая в активной виртуальной среде) запускает интерпретатор Python, который может использоваться для работы с информацией в базе данных проекта. В данном случае мы импортируем модель Topic из модуля learning_logs.models . Затем метод Topic.objects.all() используется
для получения всех экземпляров модели Topic; возвращаемый список называется итоговым набором (queryset).
Содержимое итогового набора перебирается точно так же, как и содержимое списка. Например, просмотр идентификаторов, назначенных каждому объекту темы, выполняется так:
>>> topics = Topic.objects.all()
>>> for topic in topics:
... print(topic.id, topic)
...
1 Chess
2 Rock Climbing
Итоговый набор сохраняется в topics, после чего выводится атрибут id каждого объекта topic и его строковое представление. Мы видим, что теме Chess присвоен идентификатор 1, а Rock Climbing присвоен идентификатор 2.
Зная идентификатор конкретного объекта, можно при помощи метода Topic.objects.get() получить этот объект и проанализировать содержащиеся в нем атрибуты. Просмотрим значения text и date_added для темы Chess:
>>> t = Topic.objects.get(id=1)
>>> t.text
'Chess'
>>> t.date_added
datetime.datetime(2019, 2, 19, 1, 55, 31, 98500, tzinfo=<UTC>)
Также можно просмотреть записи, относящиеся к конкретной теме. Ранее мы определили атрибут topic для модели Entry. Он был экземпляром ForeighKey, представляющим связь между записью и темой. Django может использовать эту свзяь для получения всех записей, относящихся к некоторой теме:
❶ >>> t.entry_set.all()
<QuerySet [<Entry: The opening is the first part of the game, roughly...>,
<Entry:
In the opening phase of the game, it's important t...>]>
Чтобы получить данные через отношение внешнего ключа, воспользуйтесь именем связанной модели, записанным в нижнем регистре, за которым следует символ подчеркивания и слово set . Допустим, у вас имеются модели Pizza и Topping и модель Topping связана с Pizza через внешний ключ. Если ваш объект называется my_pizza, для получения всех связанных с ним экземпляров Topping используется выражение my_pizza.topping_set.all().
Мы будем использовать такой синтаксис при переходе к программированию страниц, которые могут запрашиваться пользователями. Оболочка очень удобна тогда, когда вы хотите проверить, что ваш код получает нужные данные. Если в оболочке код работает так, как задумано, можно ожидать, что он будет правильно работать и в файлах, которые вы создаете в своем проекте. Если код выдает ошибки или не
загружает те данные, которые должен загружать, вам будет намного проще отладить его в простой оболочке, чем при работе с файлами, генерирующими веб-страницы. В книге мы не будем часто возвращаться к оболочке, но вам не стоит забывать о ней — это полезный инструмент, который поможет вам освоить синтаксис Django для работы с данными проекта.
ПРИМЕЧАНИЕ При каждом изменении модели необходимо перезапустить оболочку, чтобы увидеть результаты этих изменений. Чтобы завершить сеанс работы с оболочкой, нажмите Сtrl+D; в Windows нажмите Ctrl+Z, а затем Enter.

СОЗДАНИЕ СТРАНИЦ: ДОМАШНЯЯ СТРАНИЦА LEARNING LOG

Обычно процесс создания веб-страниц в Django состоит из трех стадий: определения URL, написания представлений и написания шаблонов. Сначала следует определить схемы (patterns) URL. Схема URL описывает структуру URL-адреса и сообщает Django, на какие компоненты следует обращать внимание при сопоставлении запроса браузера с URL-адресом на сайте, чтобы выбрать возвращаемую страницу.
Затем каждый URL-адрес связывается с конкретным представлением — функция представление читает и обрабатывает данные, необходимые странице. Функция представления часто вызывает шаблон, который строит страницу, подходящую для передачи браузеру. Чтобы вы лучше поняли, как работает этот механизм, создадим домашнюю страницу для приложения Learning Log. Мы определим URL-адрес домашней страницы, напишем для него функцию представления и создадим простой шаблон.
Так как мы сейчас всего лишь убеждаемся в том, что Learning Log работает как положено, страница пока останется простой. Когда приложение будет завершено, вы можете заниматься его оформлением сколько душе угодно; приложение, которое хорошо выглядит, но не работает, бессмысленно. Пока на домашней странице будет отображаться только заголовок и краткое описание.

СОПОСТАВЛЕНИЕ URL

Пользователь запрашивает страницы, вводя URL-адреса в браузере и щелкая на ссылках, поэтому мы должны решить, какие URL-адреса понадобятся в нашем проекте. Начнем с URL домашней страницы: это базовый адрес, используемый для обращения к проекту. На данный момент базовый URL-адрес http://localhost:8000/ возвращает сайт, сгенерированный Django по умолчанию; он сообщает о том, что проект был создан успешно. Мы изменим домашнюю страницу, связав базовый URL-адрес с домашней страницей Learning Log.
В каталоге проекта learning_log откройте файл urls.py. Вы увидите в нем следующий код:
urls.py
❶ from django.contrib import admin
from django.urls import path
❷ urlpatterns = [
❸ path('admin/', admin.site.urls),
]
Первые две строки импортируют функции и модули, управляющие URL-адресами проекта и административным сайтом . В теле файла определяется переменная urlpatterns . В файле urls.py, представляющем проект в целом, переменная urlpatterns включает наборы URL-адресов из приложений в проект. Код  включает модуль admin.site.urls, определяющий все URL-адреса, которые могут запрашиваться с административного сайта.
Добавим в этот файл URL-адреса learning_logs:
from django.contrib import admin
from django.urls import path, include
urlpatterns = [
path('admin/', admin.site.urls),
❶ path('', include('learning_logs.urls')),
]
В точке  добавляется строка включения модуля learning_logs.urls.
Файл urls.py по умолчанию находится в каталоге learning_log; теперь нужно создать второй файл urls.py в папке learning_logs. Создайте новый файл Python, сохраните его под именем urls.py в learning_logs и включите в него следующий код:
urls.py
❶ """Определяет схемы URL для learning_logs."""
❷ from django.urls import path
❸ from . import views
❹ app_name = 'learning_logs'
❺ urlpatterns = [
# Домашняя страница
❻ path('', views.index, name='index'),
]
Чтобы было понятно, с какой версией urls.py мы работаем, в начало файла добавляется строка документации . Затем импортируется функция path, она необходима для связывания URL с представлениями . Также импортируется модуль views ; точка приказывает Python импортировать представления из каталога, в котором находится текущий модуль urls.py. Переменная app_name помогает Django отличить этот файл urls.py от одноименных файлов в других приложениях в проекте . Переменная urlpatterns в этом модуле представляет собой список страниц, которые могут запрашиваться из приложения learning_logs .
Схема URL представляет собой вызов функции path() с тремя аргументами . Первый аргумент содержит строку, которая помогает Django правильно маршрутизировать текущий запрос. Django получает запрашиваемый URL и пытается отобразить его на представление. Для этого Django ищет среди всех определенных схем URL ту, которая соответствует текущему запросу. Базовый URL-адрес проекта (http://localhost:8000/) игнорируется, так что пустая строка совпадает с базовым URL-адресом. Любой другой URL-адрес не будет соответствовать этому выражению, и Django вернет страницу с ошибкой, если запрашиваемый URL не соответствует ни одной из существующих схем URL.
Второй аргумент path()  определяет вызываемую функцию из views.py. Когда запрашиваемый URL-адрес соответствует регулярному выражению, Django вызывает index() из views.py (мы напишем эту функцию представления в следующем разделе). Третий аргумент определяет имя index для этой схемы URL, чтобы на нее можно было ссылаться в других частях кода. Каждый раз, когда потребуется предоставить ссылку на домашнюю страницу, мы будем использовать это имя вместо URL.

НАПИСАНИЕ ПРЕДСТАВЛЕНИЯ

Функция представления получает информацию из запроса, подготавливает данные, необходимые для построения страницы, и возвращает данные браузеру — часто с использованием шаблона, определяющего внешний вид страницы.
Файл views.py в learning_logs был сгенерирован автоматически при выполнении команды python manage.py startapp. На данный момент его содержимое выглядит так:
views.py
from django.shortcuts import render
# Создайте здесь свои представления.
Сейчас файл только импортирует функцию render(), которая генерирует ответ на основании данных, полученных от представлений. Откройте файл представления и добавьте следующий код домашней страницы:
from django.shortcuts import render
def index(request):
"""Домашняя страница приложения Learning Log"""
return render(request, 'learning_logs/index.html')
Если URL запроса совпадает с только что определенной схемой, Django ищет в файле views.py функцию с именем index(), после чего передает этой функции представления объект request. В нашем случае никакая обработка данных для страницы не нужна, поэтому код функции сводится к вызову render(). Функция render() использует два аргумента — исходный объект запроса и шаблон, используемый для построения страницы. Давайте напишем этот шаблон.

НАПИСАНИЕ ШАБЛОНА

Шаблон определяет общий внешний вид страницы, а Django заполняет его соответствующими данными при каждом запросе страницы. Шаблон может обращаться к любым данным, полученным от представления. Так как наше представление домашней страницы никаких данных не предоставляет, шаблон получается относительно простым.
В каталоге learning_logs создайте новый каталог с именем templates. В каталоге templates создайте другой каталог с именем learning_logs. На первый взгляд такая структура кажется избыточной (каталог learning_logs в каталоге templates внутри каталога learning_logs), но созданная таким образом структура будет однозначно интерпретироваться Django даже в контексте большого проекта, состоящего из множества отдельных приложений. Во внутреннем каталоге learning_logs создайте новый файл с именем index.html (таким образом, полное имя файла имеет вид learning_log/learning_logs/templates/learning_logs/index.html). Включите в него следующий текст:
index.html
<p>Learning Log</p>
<p>Learning Log helps you keep track of your learning, for any topic you're
learning about.</p>
Это очень простой файл. Если вы не знакомы с синтаксисом HTML, теги <p></p> обозначают абзацы. Тег <p> открывает абзац, а тег </p> закрывает его. В нашей стра
нице два абзаца: первый содержит заголовок, а второй описывает, что пользователь может сделать с помощью приложения Learning Log.
Теперь при запросе базового URL-адреса проекта http://localhost:8000/ вы увидите только что построенную страницу вместо страницы по умолчанию. Django берет запрошенный URL-адрес и видит, что он совпадает со схемой ''; в этом случае Django вызывает функцию views.index(), что приводит к построению страницы с использованием шаблона, содержащегося в index.html. Полученная страница показана на рис. 18.3.
И хотя может показаться, что для одной страницы этот процесс слишком сложен, такое разделение URL-адресов, представлений и шаблонов работает хорошо. Оно позволяет сосредоточиться на отдельных аспектах проекта, а в более крупных проектах отдельные участники могут сосредоточиться на тех областях, в которых они наиболее сильны. Например, специалист по базам данных может заняться моделями, программист — кодом представления, а веб-дизайнер — шаблонами.
ПРИМЕЧАНИЕ Вы можете получить следующее сообщение об ошибке:
ModuleNotFoundError: No module named 'learning_logs.urls'
В таком случае остановите сервер разработки нажатием клавиш Ctrl+C в терминальном окне, в котором была введена команда runserver. Затем снова введите команду python manage.py runserver. Каждый раз, когда вы сталкиваетесь с подобными ошибками, попробуйте остановить и перезапустить сервер.

ПОСТРОЕНИЕ ДРУГИХ СТРАНИЦ

Теперь, когда вы начали представлять процесс построения страниц, можно переходить к построению проекта Learning Log. Мы создадим две страницы для вывода данных: на одной будет выводиться список всех тем, а на другой — все записи по конкретной теме. Для каждой страницы мы создадим схему URL, напишем функцию представления и создадим шаблон. Но прежде чем переходить к работе, стоит создать базовый шаблон, от которого будут наследовать все шаблоны этого проекта.
Наследование шаблонов
При построении сайта некоторые элементы почти всегда повторяются на каждой странице. Вместо того чтобы встраивать эти элементы непосредственно в страницы, вы можете написать базовый шаблон с повторяющимися элементами; все страницы будут наследовать от этого шаблона. Такое решение позволит сосредоточиться на разработке уникальных аспектов каждой страницы и существенно упростит изменение общего оформления проекта в целом.
Родительский шаблон
Начнем с создания шаблона base.html в одном каталоге с файлом index.html. Этот файл будет содержать элементы, общие для всех страниц; все остальные шаблоны наследуют от base.html. Пока единственным элементом, который должен повторяться на каждой странице, остается заголовок в верхней части страницы. Так как шаблон будет включаться в каждую страницу, преобразуем заголовок в ссылку на домашнюю страницу:
base.html
<p>
❶ <a href="{% url 'learning_logs:index' %}">Learning Log</a>
</p>
❷ {% block content %}{% endblock content %}
Первая часть файла создает абзац с именем проекта, который также работает как ссылка на домашнюю страницу. Для построения ссылки использовался шаблонный тег, обозначенный фигурными скобками и знаками процента {% %}. Шаблонный тег представляет собой блок кода, который генерирует информацию для вывода на странице. В данном примере шаблонный тег {% url 'learning_logs:index' %} генерирует URL-адрес, соответствующий схеме URL, определенной в файле learning_logs/urls.py с именем 'index' . В данном примере learning_logs — пространство имен, а index — схема URL с уникальным именем в этом пространстве имен.
Пространство имен определяется значением, присвоенным app_name в файле learning_logs/urls.py.
В этой простой странице HTML ссылка заключается в якорный тег:
<a href="url_ссылки">текст ссылки</a>
Генерирование URL-адреса шаблонным тегом существенно упрощает актуализацию ссылок. Чтобы изменить URL-адрес в проекте, достаточно изменить схему URL в urls.py, а Django автоматически вставит обновленный URL-адрес при следующем запросе страницы. Каждая страница в проекте будет наследовать от base.html, так что в дальнейшем на каждой странице будет содержаться ссылка на домашнюю страницу.
В точке  вставляется пара тегов block. Блок с именем content резервирует место; информация, попадающая в блок content, будет определяться дочерним шаблоном.
Дочерний шаблон не обязан определять каждый блок в своем родителе, так что в родительских шаблонах можно зарезервировать место для любого количества блоков, а дочерний шаблон будет использовать столько из них, сколько потребуется.
ПРИМЕЧАНИЕ В коде Python почти всегда используются отступы в четыре пробела. Файлы шаблонов обычно имеют больший уровень вложенности, чем файлы Python, поэтому каждый уровень отступа обычно обозначается двумя пробелами. Будьте внимательны и действуйте последовательно.

ДОЧЕРНИЙ ШАБЛОН

Теперь нужно переписать файл index.html так, чтобы он наследовал от base.html. Обновленный файл index.html выглядит так:
index.html
❶ {% extends "learning_logs/base.html" %}
❷ {% block content %}
<p>Learning Log helps you keep track of your learning, for any topic you're
learning about.</p>
❸ {% endblock content %}
Сравнивая этот файл с исходной версией index.html, мы видим, что заголовок Learning Log заменен кодом наследования от родительского шаблона . В первой строке дочернего шаблона должен находиться тег {% extends %}, который сообщает Django, от какого родительского шаблона он наследует. Файл base.html является частью learning_logs, поэтому learning_logs включается в путь к родительскому шаблону. Эта строка извлекает все содержимое из шаблона base.html и позволяет index.html определить, что должно попасть в пространство, зарезервированное блоком content.
Блок content определяется в точке  вставкой тега {% block %} с именем content. Все, что не наследуется от родительского шаблона, попадает в блок content. В данном случае это абзац с описанием проекта Learning Log. В точке  мы сообщаем о том, что определение content завершено, при помощи тега {% endblock content %}. Наличие имени у {% endblock %} не обязательно, но если шаблон увеличится и станет включать несколько блоков, будет полезно сразу видеть, какой именно блок завершается.
Вероятно, вы уже начинаете понимать преимущества наследования шаблонов: в дочерний шаблон достаточно включить информацию, уникальную для этой страницы. Такой подход не только упрощает каждый шаблон, но и значительно упрощает изменение сайта. Чтобы изменить элемент, общий для многих страниц, достаточно изменить элемент в родительском шаблоне. Внесенные изменения будут автоматически перенесены на каждую страницу, наследующую от этого шаблона. В проекте из десятков и сотен страниц такая структура значительно упрощает и ускоряет доработку сайта.
ПРИМЕЧАНИЕ В больших проектах часто создается один родительский шаблон base. html для всего сайта и родительские шаблоны для каждого крупного раздела сайта. Все шаблоны разделов наследуют от base.html, и каждая страница сайта наследует от шаблона раздела. При такой структуре вы сможете легко изменять оформление и поведение сайта в целом, любого его раздела или отдельной страницы. Данная конфигурация сильно повышает эффективность работы и стимулирует разработчика к дальнейшему совершенствованию сайта.

СТРАНИЦА СО СПИСКОМ ТЕМ

Разобравшись с тем, как эффективно организовать построение страниц, мы можем сосредоточиться на следующих двух страницах: списке всех тем и списке записей по одной теме. На странице тем выводится перечень всех тем, созданных пользователями, и это первая страница, на которой нам придется работать с данными.
Схема URL для тем
Сначала нужно определить URL для страницы тем. Обычно в таких случаях выбирается простой фрагмент URL, который отражает суть информации, представленной на странице. Мы воспользуемся словом topics, так что для получения страницы будет использоваться URL http://localhost:8000/topics/. А вот какие изменения следует внести в learning_logs/urls.py:
urls.py
"""Определяет схемы URL для learning_logs."""
...
urlpatterns = [
# Домашняя страница
path('', views.index, name='index'),
# Страница со списком всех тем.
❶ path('topics/', views.topics, name='topics'),
]
Мы просто добавили topics/ в аргумент регулярного выражения, используемый с URL-адресом домашней страницы . Когда Django проверяет запрашиваемый URL-адрес, эта схема совпадет с любым URL-адресом, который состоит из базового URL-адреса и слова topics. Слеш в конце можно включить, а можно не включать, но после слова topics ничего быть не должно, иначе схема не совпадет. Любой запрос с URL-адресом, соответствующим этой схеме, будет передан функции topics() в views.py.

ПРЕДСТАВЛЕНИЕ TOPICS

Функция topics() должна получать данные из базы данных и отправлять их шаблону. Обновленная версия views.py выглядит так:
views.py
from django.shortcuts import render
❶ from .models import Topic
def index(request):
...
❷ def topics(request):
"""Выводит список тем."""
❸ topics = Topic.objects.order_by('date_added')
❹ context = {'topics': topics}
❹ return render(request, 'learning_logs/topics.html', context)
Сначала импортируется модель, связанная с нужными данными . Функции topics() необходим один параметр: объект request, полученный Django от сервера . В точке  выдается запрос к базе данных на получение объектов Topic, отсортированных по атрибуту date_added. Полученный итоговый набор сохраняется в topics.
В точке  определяется контекст, который будет передаваться шаблону. Контекст представляет собой словарь, в котором ключами являются имена, используемые в шаблоне для обращения к данным, а значениями — данные, которые должны передаваться шаблону. В данном случае существует всего одна пара «ключ-значение», которая содержит набор тем, отображаемых на странице. При построении страницы, использующей данные, функции render() передается переменная context, а также объект request и путь к шаблону .
Шаблон topics
Шаблон страницы со списком тем получает словарь context, чтобы шаблон мог использовать данные, предоставленные topics(). Создайте файл с именем topics. html в одном каталоге с index.html. Вывод списка тем в шаблоне осуществляется следующим образом:
topics.html
{% extends "learning_logs/base.html" %}
{% block content %}
<p>Topics</p>
❶ <ul>
❷ {% for topic in topics %}
❸ <li>{{ topic }}</li>
❹ {% empty %}
<li>No topics have been added yet.</li>
❺ {% endfor %}
❻ </ul>
{% endblock content %}
Сначала тег {% extends %} объявляет о наследовании от base.html, как и в случае с шаблоном index, после чего открывается блок content. Тело страницы содержит маркированный (bulleted) список введенных тем. В стандартном языке HTML маркированный список называется неупорядоченным списком и обозначается тегами <ul></ul>. Список тем начинается в точке .
В точке  находится другой шаблонный тег, эквивалентный циклу for, для перебора списка topics из словаря context. Код, используемый в шаблоне, отличается от Python некоторыми важными особенностями. Python использует отступы для обозначения строк, входящих в тело цикла. В шаблоне каждый цикл for должен снабжаться явным тегом {% endfor %}, обозначающим конец цикла. Таким образом, в шаблонах часто встречаются циклы следующего вида:
{% for элемент in список %}
действия для каждого элемента
{% endfor %}
В цикле каждая тема должна быть преобразована в элемент маркированного списка. Чтобы вывести значение переменной в шаблоне, заключите ее имя в двойные фигурные скобки. Фигурные скобки на странице не появятся; они всего лишь сообщают Django об использовании шаблонной переменной. Код {{ topic }} в точке  будет заменен значением topic при каждом проходе цикла. Тег HTML <li></li> обозначает элемент списка. Все, что находится между тегами, в паре тегов <ul></ul>, будет отображаться как элемент маркированного списка.
В точке  находится шаблонный тег {% empty %}, который сообщает Django, что делать при отсутствии элементов в списке. В нашем примере выводится сообщение о том, что темы еще не созданы. Последние две строки завершают цикл for  и маркированный список .
Затем необходимо изменить базовый шаблон и включить ссылку на страницу с темами. Добавьте следующий код в base.html: