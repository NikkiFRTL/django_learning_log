НАПИСАНИЕ СПЕЦИФИКАЦИИ

Мы напишем веб-приложение с именем Learning Log, при помощи которого пользователь сможет вести журнал интересующих его
тем и создавать записи в журнале во время изучения каждой темы. Домашняя страница Learning Log содержит описание сайта
и приглашает пользователя зарегистрироваться либо ввести свои учетные данные. После успешного входа пользователь
получает возможность создавать новые темы, добавлять новые записи, читать и редактировать существующие записи.

СОЗДАНИЕ ВИРТУАЛЬНОЙ СРЕДЫ

Для работы с Django необходимо сначала создать виртуальную среду для работы. Виртуальная среда представляет собой
подраздел системы, в котором вы можете устанавливать пакеты в изоляции от всех остальных пакетов Python. Отделение
библиотек одного проекта от других проектов принесет пользу при развертывании Learning Log на сервере в главе 20.
Создайте для проекта новый каталог с именем learning_log, перейдите в этот каталог в терминальном режиме и создайте
виртуальную среду следующими командами:
learning_log$ python -m venv ll_env
learning_log$
Команда запускает модуль виртуальной среды venv и использует его для создания виртуальной среды с именем ll_env
(обратите внимание: в имени ll_env две буквы l, а не одна). Если для запуска программ или установки пакетов
используется другая команда (например, python3), подставьте ее на место python.

АКТИВИЗАЦИЯ ВИРТУАЛЬНОЙ СРЕДЫ

После того как виртуальная среда будет создана, ее необходимо активизировать следующей командой:
learning_log$ source ll_env/bin/activate
❶ (ll_env)learning_log$
Команда запускает сценарий activate из каталога ll_env/bin. Когда среда активизируется, ее имя выводится в круглых
скобках ; теперь вы можете устанавливать пакеты в среде и использовать те пакеты, что были установлены ранее. Пакеты,
установленные в ll_env, будут доступны только в то время, пока среда остается активной.
ПРИМЕЧАНИЕ Если вы работаете в системе Windows, используйте команду ll_env\Scripts\activate (без слова source) для
активизации виртуальной среды. Если вы используете PowerShell, слово Activate должно начинаться с буквы верхнего регистра.
Чтобы завершить использование виртуальной среды, введите команду deactivate:
(ll_env)learning_log$ deactivate
learning_log$
Среда также становится неактивной при закрытии терминального окна, в котором она работает.

УСТАНОВКА DJANGO

После того как вы создали свою виртуальную среду и активизировали ее, установите Django:
(ll_env)learning_log$ pip install django
Collecting django
...
Installing collected packages: pytz, django
Successfully installed django-2.2.0 pytz-2018.9 sqlparse-0.2.4
(ll_env)learning_log$
Так как вы работаете в виртуальной среде, эта команда выглядит одинаково во всех системах. Использовать флаг --user
не нужно, как и использовать более длинные команды вида python -m pip install имя_пакета.
Помните, что с Django можно работать только в то время, пока среда остается активной.
ПРИМЕЧАНИЕ Новая версия Django выходит приблизительно раз в восемь месяцев; возможно, при установке Django будет
выведен новый номер версии. Скорее всего, проект будет работать в том виде, в каком он здесь приведен, даже в новых
версиях Django. Если вы хотите использовать ту же версию Django, которая используется здесь, введите команду
pip install django==2.2.*. Команда установит последний выпуск Django 2.2. Если у вас возникнут проблемы, связанные
с версией, обращайтесь к электронным ресурсам книги по адресу https://nostarch.com/pythoncrashcourse2e/.
Создание проекта в Django
Не выходя из активной виртуальной среды (пока ll_env выводится в круглых скобках), введите следующие команды для
создания нового проекта:
❶ (ll_env)learning_log$ django-admin.py startproject learning_log . (с точкой)
❷ (ll_env)learning_log$ ls
learning_log ll_env manage.py
❸ (ll_env)learning_log$ ls learning_log
__init__.py settings.py urls.py wsgi.py
Команда  приказывает Django создать новый проект с именем learning_log. Точка в конце команды создает новый проект
со структурой каталогов, которая упрощает развертывание приложения на сервере после завершения разработки.
Команда ls (dir в Windows)  показывает, что Django создает новый каталог с именем learning_log. Также создается файл manage.py — короткая программа, которая получает команды и передает их соответствующей части Django для выполнения. Мы используем эти команды для управления такими задачами, как работа с базами данных и запуск серверов.
В каталоге learning_log находятся четыре файла , важнейшими из которых являются файлы settings.py, urls.py и wsgi.py. Файл settings.py определяет то, как Django взаимодействует с вашей системой и управляет вашим проектом. Мы изменим некоторые из существующих настроек и добавим несколько новых настроек в ходе разработки проекта. Файл urls.py сообщает Django, какие страницы следует строить в ответ на запросы браузера. Файл wsgi.py помогает Django предоставлять созданные файлы (имя файла является сокращением от «Web Server Gateway Interface»).

СОЗДАНИЕ БАЗЫ ДАННЫХ

Так как Django хранит большую часть информации в базе данных, относящейся к проекту, на следующем этапе необходимо создать базу данных, с которой Django сможет работать. Введите следующую команду (все еще не покидая активную среду):
(ll_env)learning_log$ python manage.py migrate
❶ Operations to perform:
Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
Applying contenttypes.0001_initial... OK
Applying auth.0001_initial... OK
...
Applying sessions.0001_initial... OK
❷ (ll_env)learning_log$ ls
db.sqlite3 learning_log ll_env manage.py
Каждое изменение базы данных называется миграцией. Первое выполнение команды migrate приказывает Django проверить, что база данных соответствует текущему состоянию проекта. Когда мы впервые выполняем эту команду в новом проекте с использованием SQLite (вскоре мы расскажем о SQLite более подробно), Django создает новую базу данных за нас. В точке  Django сообщает о создании и подготовке базы данных к хранению информации, необходимой для выполнения административных операций и аутентификации.
Выполнение команды ls показывает, что Django создает другой файл с именем db.sqlite3 . SQLite — база данных, работающая с одним файлом; она идеально
подходит для написания простых приложений, потому что вам не нужно особенно следить за управлением базой данных.
ПРИМЕЧАНИЕ В активной виртуальной среде для выполнения команд manage.py используется команда python, даже если для запуска других программ вы используете другую команду (например, python3). В виртуальной среде команда python относится к версии Python, создавшей виртуальную среду.

ПРОСМОТР ПРОЕКТА

Убедимся в том, что проект был создан правильно. Введите команду runserver для просмотра текущего состояния проекта:
(ll_env)learning_log$ python manage.py runserver
Watchman unavailable: pywatchman not installed.
Watching for file changes with StatReloader
Performing system checks...
❶ System check identified no issues (0 silenced).
February 18, 2019 - 16:26:07
❷ Django version 2.2.0, using settings 'learning_log.settings'
❸ Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
Django запускает сервер, называемый сервером разработки, чтобы вы могли просмотреть проект в своей системе и проверить, как он работает. Когда вы запрашиваете страницу, вводя URL в браузере, сервер Django отвечает на запрос; для этого он строит соответствующую страницу и отправляет страницу браузеру.
В точке  Django проверяет правильность созданного проекта; в точке  выводится версия Django и имя используемого файла настроек; в точке  возвращается URL-адрес, по которому доступен проект. URL http://127.0.0.1:8000/ означает, что проект ведет прослушивание запросов на порте 8000 локального хоста (localhost), то есть вашего компьютера. Термином «локальный хост» обозначается сервер, который обрабатывает только запросы вашей системы; он не позволяет никому другому просмотреть разрабатываемые страницы.
Теперь откройте браузер и введите URL http://localhost:8000/ — или http://127.0.0.1:8000/, если первый адрес не работает. Вы увидите нечто похожее на рис. 18.1 — страницу, которую создает Django, чтобы сообщить вам, что все пока работает правильно. Пока не завершайте работу сервера (но когда вы захотите прервать ее, это можно сделать нажатием клавиш Ctrl+C в терминале, в котором была введена команда runserver).
ПРИМЕЧАНИЕ Если вы получаете сообщение об ошибке «Порт уже используется», прикажите Django использовать другой порт; для этого введите команду python manage.py runserver 8001 и продолжайте перебирать номера портов по возрастанию, пока не найдете открытый порт.

НАЧАЛО РАБОТЫ НАД ПРИЛОЖЕНИЕМ

Проект Django представляет собой группу отдельных приложений, совместная работа которых обеспечивает работу проекта в целом. Пока мы создадим одно приложение, которое будет выполнять большую часть работы в нашем проекте. Другое приложение для управления учетными записями пользователей будет добавлено в главе 19.
Оставьте сервер разработки выполняться в терминальном окне, открытом ранее. Откройте новое терминальное окно (или вкладку) и перейдите в каталог, содержащий manage.py. Активизируйте виртуальную среду и выполните команду startapp:
learning_log$ source ll_env/bin/activate
(ll_env)learning_log$ python manage.py startapp learning_logs
❶ (ll_env)learning_log$ ls
db.sqlite3 learning_log learning_logs ll_env manage.py
❷ (ll_env)learning_log$ ls learning_logs/
admin.py __init__.py migrations models.py tests.py views.py
Команда startapp имя_приложения приказывает Django создать инфраструктуру, необходимую для построения приложения. Заглянув сейчас в каталог проекта, вы найдете в нем новый подкаталог с именем learning_logs . Откройте этот каталог, чтобы увидеть, какие файлы были созданы Django . Самые важные файлы в этом каталоге — models.py, admin.py и views.py. Файл models.py будет использоваться для определения данных, которыми нужно управлять в нашем приложении. К файлам admin.py и views.py мы вернемся позднее.
Определение моделей
Подумаем, какие данные нам понадобятся. Каждый пользователь создает набор тем в своем журнале. Каждая запись, которую он сделает, будет привязана к определенной теме, а записи будут выводиться в текстовом виде. Также необходимо хранить временную метку каждой записи, чтобы пользователь знал, когда эта запись была создана.
Откройте файл models.py и просмотрите его текущее содержимое:
models.py
from django.db import models
# Создайте здесь свои модели.
Модуль с именем models импортируется автоматически, и нам предлагается создать свои модели. Модель сообщает Django, как работать с данными, которые будут храниться в приложении. С точки зрения кода модель представляет собой обычный класс; она содержит атрибуты и методы, как и все остальные классы, рассматривавшиеся нами ранее. Вот как выглядит модель тем обсуждения, которые будут сохраняться пользователями:
from django.db import models
class Topic(models.Model):
"""Тема, которую изучает пользователь"""
❶ text = models.CharField(max_length=200)
❷ date_added = models.DateTimeField(auto_now_add=True)
❸ def __str__(self):
"""Возвращает строковое представление модели."""
return self.text
Мы создали класс с именем Topic, наследующий от Model — родительского класса, включенного в Django и определяющего базовую функциональность модели. В класс Topic добавляются два атрибута: text и date_added.
Атрибут text содержит данные CharField — блок данных, состоящий из символов, то есть текст . Атрибуты CharField могут использоваться для хранения небольших объемов текста: имен, заголовков, названий городов и т. д. При определении атрибута CharField необходимо сообщить Django, сколько места нужно зарезервировать для него в базе данных. В данном случае задается максимальная длина max_length, равная 200 символам; этого должно быть достаточно для хранения большинства имен тем.
Атрибут date_added содержит данные DateTimeField — блок данных для хранения даты и времени . Аргумент auto_add_now=True приказывает Django автоматически присвоить этому атрибуту текущую дату и время каждый раз, когда пользователь создает новую тему.
ПРИМЕЧАНИЕ Полный список всех полей, которые могут использоваться в модели, приведены в документе Django Model Field Reference на https://docs.djangoproject.com/en/2.2/ref/models/fields/. Возможно, вся эта информация вам сейчас не понадобится, но она будет в высшей степени полезной, когда вы начнете разрабатывать собственные приложения.
Необходимо сообщить Django, какой атрибут должен использоваться по умолчанию при вводе информации о теме. Django вызывает метод __str__() для вывода простого представления модели. Мы написали реализацию __str__(), которая возвращает строку, хранящуюся в атрибуте text .
Активизация моделей
Чтобы использовать модели, необходимо приказать Django включить приложение в общий проект. Откройте файл settings.py (из каталога learning_log/learning_log) и найдите в нем раздел, который сообщает Django, какие приложения установлены в проекте:
settings.py
...
INSTALLED_APPS = (
'django.contrib.admin',
'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.messages',
'django.contrib.staticfiles',
)
...
Добавьте наше приложение в этот кортеж; измените содержимое INSTALLED_APPS, чтобы оно выглядело так:
...
INSTALLED_APPS = (
# Мои приложения
'learning_logs',
# Приложения django по умолчанию.
'django.contrib.admin',
...
]
...
Группировка приложений в проекте упрощает управление ими по мере того, как проект растет, а количество приложений увеличивается. Здесь мы создаем раздел, который пока содержит только приложение learning_logs. Очень важно разместить свои приложения перед приложениями по умолчанию на случай, если вам понадобится переопределить поведение таких приложений.
Затем необходимо приказать Django изменить базу данных для хранения информации, относящейся к модели Topic. В терминальном окне введите следующую команду:
(ll_env)learning_log$ python manage.py makemigrations learning_logs
Migrations for 'learning_logs':
learning_logs/migrations/0001_initial.py
- Create model Topic
(ll_env)learning_log$
По команде makemigrations Django определяет, как изменить базу данных для хранения информации, связанной с новыми моделями. Из результатов видно, что Django создает файл миграции с именем 0001_initial.py. Эта миграция создает в базе данных таблицу для модели Topic.
Теперь применим миграцию для автоматического изменения базы данных:
(ll_env)learning_log$ python manage.py migrate
Operations to perform:
Apply all migrations: admin, auth, contenttypes, learning_logs, sessions
Running migrations:
❶ Applying learning_logs.0001_initial... OK
Большая часть вывода этой команды совпадает с выводом, полученным при первом выполнении команды migrate. Обратить внимание следует на строку ; здесь Django подтверждает, что применение миграции для learning_logs прошло успешно.
Каждый раз, когда вы захотите изменить данные, которыми управляет Learning Log, выполните эти три действия: внесите изменения в models.py, вызовите makemigrations для learning_logs и прикажите Django выполнить миграцию проекта (migrate).

АДМИНИСТРАТИВНЫЙ САЙТ DJANGO

Django позволяет легко работать с моделями, определенными для приложения, через административный сайт. Этот сайт используется администраторами сайта,
а не рядовыми пользователями. В этом разделе мы создадим административный сайт и используем его для добавления некоторых тем через модель Topic.

СОЗДАНИЕ СУПЕРПОЛЬЗОВАТЕЛЯ

Django позволяет создать пользователя, обладающего полным набором привилегий на сайте; такой пользователь называется
суперпользователем. Привилегии управляют действиями, которые разрешено выполнять пользователю. На самом жестком уровне
привилегий пользователь может только читать общедоступную информацию на сайте. Зарегистрированным пользователям обычно
предоставляется привилегия чтения своих приватных данных, а также избранной информации, доступной только для участников
сообщества. Для эффективного администрирования веб-приложения владельцу сайта обычно должна быть доступна вся
информация, хранящаяся на сайте. Хороший администратор внимательно относится к конфиденциальной информации пользователя,
потому что пользователи доверяют тем приложениям, с которыми они работают.
Чтобы создать суперпользователя в Django, введите следующую команду и ответьте на запросы:
(ll_env)learning_log$ python manage.py createsuperuser
❶ Username (leave blank to use 'eric'): ll_admin
❷ Email address:
❸ Password: 1
Password (again):
Superuser created successfully.
(ll_env)learning_log$
При получении команды createsuperuser Django предлагает ввести имя пользователя, который является суперпользователем .
Здесь мы вводим имя ll_admin, но вы можете ввести любое имя на свое усмотрение. Также можно ввести адрес электронной
почты или оставить это поле пустым . После этого следует дважды ввести пароль .
ПРИМЕЧАНИЕ Часть конфиденциальной информации может быть скрыта от администраторов сайта. Например, Django на самом деле
не сохраняет введенный пароль; вместо этого сохраняется хеш — специальная строка, построенная на основе пароля. И когда
в будущем вы вводите пароль, Django снова хеширует введенные данные и сравнивает результат с хранимым хешем. Если два
хеша совпадают, то проверка пройдена. Если же хакер в результате атаки получит доступ к базе данных сайта, то он сможет
прочитать только хранящийся в базе хеш, но не пароли. При правильной настройке сайта восстановить исходные пароли из
хешей почти невозможно.

РЕГИСТРАЦИЯ МОДЕЛИ НА АДМИНИСТРАТИВНОМ САЙТЕ

Django добавляет некоторые модели (например, User и Group) на административный сайт автоматически, но модели, которые мы
создали, придется регистрировать вручную.
При запуске приложения learning_logs Django создает файл admin.py в одном каталоге с models.py. Откройте файл admin.py:
admin.py
from django.contrib import admin
# Зарегистрируйте здесь ваши модели.
Чтобы зарегистрировать Topic на административном сайте, введите следующую команду:
from django.contrib import admin
❶ from .models import Topic
❷ admin.site.register(Topic)
Этот код импортирует регистрируемую модель Topic . Точка перед models сообщает Django, что файл models.py следует искать в одном каталоге с admin.py. Вызов admin.site.register() сообщает Django, что управление моделью должно осуществляться через административный сайт .
Теперь используйте учетную запись суперпользователя для входа на административный сайт. Введите адрес http://localhost:8000/admin/, затем имя пользователя и пароль для только что созданного суперпользователя, и вы увидите экран наподобие изображенного на рис. 18.2. На этой странице можно добавлять новых пользователей и группы, а также вносить изменения в уже существующие настройки. Также можно работать с данными, связанными с только что определенной моделью Topic.

ДОБАВЛЕНИЕ ТЕМ

Когда модель Topic была зарегистрирована на административном сайте, добавим первую тему. Щелкните на ссылке Topics, чтобы перейти к странице Topics; страница практически пуста, потому что еще нет ни одной темы для выполнения операций. Щелкните на ссылке Add Topic; открывается форма для добавления новой темы. Введите в первом поле текст Chess и щелкните на ссылке Save. Вы возвращаетесь к административной странице Topics, на которой появляется только что созданная тема.
Создадим вторую тему, чтобы у вас было больше данных для работы. Снова щелкните на ссылке Add Topic и создайте вторую тему Rock Climbing. Ссылка Save снова возвращает вас к основной странице Topics, где отображаются обе темы, Chess и Rock Climbing.
Определение модели Entry
Чтобы сохранить информацию о том, что вы узнали по этим двум темам, необходимо определить модель для записей, которые пользователь делает в своих журналах. Каждая запись должна ассоциироваться с конкретной темой. Такое отношение называется отношением «многие к одному», поскольку многие записи могут быть связаны с одной темой.
Код модели Entry (из файла models.py) выглядит так:
models.py
from django.db import models
class Topic(models.Model):
...
❶ class Entry(models.Model):
"""Информация, изученная пользователем по теме"""
❷ topic = models.ForeignKey(Topic, on_delete=models.CASCADE)
❸ text = models.TextField()
date_added = models.DateTimeField(auto_now_add=True)
❹ class Meta:
verbose_name_plural = 'entries'
def __str__(self):
"""Возвращает строковое представление модели."""
❺ return f"{self.text[:50]}..."
Класс Entry наследует от базового класса Model, как и рассмотренный ранее класс Topic . Первый атрибут, topic, является экземпляром ForeignKey . Термин внешний ключ (foreign key) происходит из теории баз данных; внешний ключ содержит ссылку на другую запись в базе данных. Таким образом каждая запись связывается с конкретной темой. Каждой теме при создании присваивается ключ, или идентификатор. Если потребуется установить связь между двумя записями данных, Django использует ключ, связанный с каждым блоком информации. Вскоре мы используем такие связи для получения всех записей, связанных с заданной темой. Аргумент on_delete=models.CASCADE сообщает Django, что при удалении темы все записи, связанные с этой темой, также должны быть удалены (это называется каскадным удалением).
Затем идет атрибут с именем text, который является экземпляром TextField . Полю такого типа ограничение размера не требуется, потому что размер отдельных записей не ограничивается. Атрибут date_added позволяет отображать записи в порядке их создания и снабжать каждую запись временной меткой.
В точке  класс Meta вкладывается в класс Entry. Класс Meta хранит дополнительную информацию по управлению моделью; в данном случае он позволяет задать специальный атрибут, который приказывает Django использовать форму множественного числа Entries при обращении более чем к одной записи. (Без этого Django будет использовать неправильную форму Entrys.)
Метод __str__() сообщает Django, какая информация должна отображаться при обращении к отдельным записям. Так как запись может быть достаточно длинным блоком текста, мы приказываем Django выводить только первые 50 символов . Также добавляется многоточие — признак вывода неполного текста.

МИГРАЦИЯ МОДЕЛИ ENTRY

Так как мы добавили новую модель, миграцию базы данных необходимо провести снова. Вскоре вы привыкнете к этому процессу: вы изменяете models.py, выполняете команду python manage.py makemigrations имя_приложения, а затем команду python manage.py migrate.
Проведите миграцию базы данных и проверьте вывод:
(ll_env)learning_log$ python manage.py makemigrations learning_logs
Migrations for 'learning_logs':
❶ learning_logs/migrations/0002_entry.py
- Create model Entry
(ll_env)learning_log$ python manage.py migrate
Operations to perform:
...
❷ Applying learning_logs.0002_entry... OK
Команда генерирует новую миграцию с именем 0002_entry.py, которая сообщает Django, как изменить базу данных для хранения информации, связанной с моделью
Entry . При выдаче команды migrate Django подтверждает, что применение миграции прошло успешно .

РЕГИСТРАЦИЯ ENTRY НА АДМИНИСТРАТИВНОМ САЙТЕ

Модель Entry тоже необходимо зарегистрировать. Файл admin.py должен выглядеть так:
admin.py
from django.contrib import admin
from .models import Topic, Entry
admin.site.register(Topic)
admin.site.register(Entry)
Вернитесь на страницу http://localhost/admin/, и вы увидите раздел Entries в категории learning_logs. Щелкните на ссылке Add для Entries или щелкните на Entries и выберите вариант Add. На экране появляется раскрывающийся список для выбора темы, для которой создается запись, и текстовое поле для ввода записи. Выберите в раскрывающемся списке вариант Chess и добавьте запись.
При выборе ссылки Save вы вернетесь к основной административной странице. Здесь проявляются преимущества использования формата text[:50] в качестве строкового представления каждой записи; работать с несколькими записями в административном интерфейсе намного удобнее, если вы видите только часть записи вместо ее полного текста.
Создайте вторую запись для темы Chess и одну запись для темы Rock Climbing, чтобы у нас были исходные данные для дальнейшей разработки Learning Log.
Интерактивная оболочка Django
Введенные данные можно проанализировать на программном уровне в интерактивном терминальном сеансе. Эта интерактивная среда, называемая оболочкой (shell) Django, прекрасно подходит для тестирования и диагностики проекта. Пример сеанса в интерактивной оболочке:
(ll_env)learning_log$ python manage.py shell
❶ >>> from learning_logs.models import Topic
>>> Topic.objects.all()
<QuerySet [<Topic: Chess>, <Topic: Rock Climbing>]>
Команда python manage.py shell (выполняемая в активной виртуальной среде) запускает интерпретатор Python, который может использоваться для работы с информацией в базе данных проекта. В данном случае мы импортируем модель Topic из модуля learning_logs.models . Затем метод Topic.objects.all() используется
для получения всех экземпляров модели Topic; возвращаемый список называется итоговым набором (queryset).
Содержимое итогового набора перебирается точно так же, как и содержимое списка. Например, просмотр идентификаторов, назначенных каждому объекту темы, выполняется так:
>>> topics = Topic.objects.all()
>>> for topic in topics:
... print(topic.id, topic)
...
1 Chess
2 Rock Climbing
Итоговый набор сохраняется в topics, после чего выводится атрибут id каждого объекта topic и его строковое представление. Мы видим, что теме Chess присвоен идентификатор 1, а Rock Climbing присвоен идентификатор 2.
Зная идентификатор конкретного объекта, можно при помощи метода Topic.objects.get() получить этот объект и проанализировать содержащиеся в нем атрибуты. Просмотрим значения text и date_added для темы Chess:
>>> t = Topic.objects.get(id=1)
>>> t.text
'Chess'
>>> t.date_added
datetime.datetime(2019, 2, 19, 1, 55, 31, 98500, tzinfo=<UTC>)
Также можно просмотреть записи, относящиеся к конкретной теме. Ранее мы определили атрибут topic для модели Entry. Он был экземпляром ForeighKey, представляющим связь между записью и темой. Django может использовать эту свзяь для получения всех записей, относящихся к некоторой теме:
❶ >>> t.entry_set.all()
<QuerySet [<Entry: The opening is the first part of the game, roughly...>,
<Entry:
In the opening phase of the game, it's important t...>]>
Чтобы получить данные через отношение внешнего ключа, воспользуйтесь именем связанной модели, записанным в нижнем
регистре, за которым следует символ подчеркивания и слово set . Допустим, у вас имеются модели Pizza и Topping и
модель Topping связана с Pizza через внешний ключ. Если ваш объект называется my_pizza, для получения
всех связанных с ним экземпляров Topping используется выражение my_pizza.topping_set.all().
Мы будем использовать такой синтаксис при переходе к программированию страниц, которые могут запрашиваться
пользователями. Оболочка очень удобна тогда, когда вы хотите проверить, что ваш код получает нужные данные.
Если в оболочке код работает так, как задумано, можно ожидать, что он будет правильно работать и в файлах,
которые вы создаете в своем проекте. Если код выдает ошибки или не загружает те данные, которые должен загружать,
вам будет намного проще отладить его в простой оболочке, чем при работе с файлами, генерирующими веб-страницы.
В книге мы не будем часто возвращаться к оболочке, но вам не стоит забывать о ней — это полезный инструмент,
который поможет вам освоить синтаксис Django для работы с данными проекта.
ПРИМЕЧАНИЕ При каждом изменении модели необходимо перезапустить оболочку, чтобы увидеть результаты этих изменений.
Чтобы завершить сеанс работы с оболочкой, нажмите Сtrl+D; в Windows нажмите Ctrl+Z, а затем Enter.

СОЗДАНИЕ СТРАНИЦ: ДОМАШНЯЯ СТРАНИЦА LEARNING LOG

Обычно процесс создания веб-страниц в Django состоит из трех стадий: определения URL, написания представлений и написания шаблонов. Сначала следует определить схемы (patterns) URL. Схема URL описывает структуру URL-адреса и сообщает Django, на какие компоненты следует обращать внимание при сопоставлении запроса браузера с URL-адресом на сайте, чтобы выбрать возвращаемую страницу.
Затем каждый URL-адрес связывается с конкретным представлением — функция представление читает и обрабатывает данные, необходимые странице. Функция представления часто вызывает шаблон, который строит страницу, подходящую для передачи браузеру. Чтобы вы лучше поняли, как работает этот механизм, создадим домашнюю страницу для приложения Learning Log. Мы определим URL-адрес домашней страницы, напишем для него функцию представления и создадим простой шаблон.
Так как мы сейчас всего лишь убеждаемся в том, что Learning Log работает как положено, страница пока останется простой. Когда приложение будет завершено, вы можете заниматься его оформлением сколько душе угодно; приложение, которое хорошо выглядит, но не работает, бессмысленно. Пока на домашней странице будет отображаться только заголовок и краткое описание.

СОПОСТАВЛЕНИЕ URL

Пользователь запрашивает страницы, вводя URL-адреса в браузере и щелкая на ссылках, поэтому мы должны решить,
какие URL-адреса понадобятся в нашем проекте. Начнем с URL домашней страницы: это базовый адрес,
используемый для обращения к проекту. На данный момент базовый URL-адрес http://localhost:8000/ возвращает сайт,
сгенерированный Django по умолчанию; он сообщает о том, что проект был создан успешно.
Мы изменим домашнюю страницу, связав базовый URL-адрес с домашней страницей Learning Log.
В каталоге проекта learning_log откройте файл urls.py. Вы увидите в нем следующий код:

urls.py
❶ from django.contrib import admin
from django.urls import path
❷ urlpatterns = [
❸ path('admin/', admin.site.urls),
]

Первые две строки импортируют функции и модули, управляющие URL-адресами проекта и административным сайтом .
В теле файла определяется переменная urlpatterns . В файле urls.py, представляющем проект в целом,
переменная urlpatterns включает наборы URL-адресов из приложений в проект. Код  включает модуль admin.site.urls,
определяющий все URL-адреса, которые могут запрашиваться с административного сайта.
Добавим в этот файл URL-адреса learning_logs:

from django.contrib import admin
from django.urls import path, include
urlpatterns = [
path('admin/', admin.site.urls),
❶ path('', include('learning_logs.urls')),
]
В точке  добавляется строка включения модуля learning_logs.urls.
Файл urls.py по умолчанию находится в каталоге learning_log; теперь нужно создать второй файл urls.py в папке
learning_logs. Создайте новый файл Python, сохраните его под именем urls.py в learning_logs и включите в него
следующий код:

urls.py
❶ """Определяет схемы URL для learning_logs."""
❷ from django.urls import path
❸ from . import views
❹ app_name = 'learning_logs'
❺ urlpatterns = [
# Домашняя страница
❻ path('', views.index, name='index'),
]

Чтобы было понятно, с какой версией urls.py мы работаем, в начало файла добавляется строка документации .
Затем импортируется функция path, она необходима для связывания URL с представлениями . Также импортируется модуль
views ; точка приказывает Python импортировать представления из каталога, в котором находится текущий модуль urls.py.
Переменная app_name помогает Django отличить этот файл urls.py от одноименных файлов в других приложениях в проекте .
Переменная urlpatterns в этом модуле представляет собой список страниц, которые могут запрашиваться из приложения
learning_logs . Схема URL представляет собой вызов функции path() с тремя аргументами .
Первый аргумент содержит строку, которая помогает Django правильно маршрутизировать текущий запрос.
Django получает запрашиваемый URL и пытается отобразить его на представление. Для этого Django ищет среди всех
определенных схем URL ту, которая соответствует текущему запросу. Базовый URL-адрес проекта (http://localhost:8000/)
игнорируется, так что пустая строка совпадает с базовым URL-адресом. Любой другой URL-адрес не будет соответствовать
этому выражению, и Django вернет страницу с ошибкой, если запрашиваемый URL не соответствует ни одной из существующих
схем URL.
Второй аргумент path()  определяет вызываемую функцию из views.py. Когда запрашиваемый URL-адрес соответствует
регулярному выражению, Django вызывает index() из views.py (мы напишем эту функцию представления в следующем разделе).
Третий аргумент определяет имя index для этой схемы URL, чтобы на нее можно было ссылаться в других частях кода.
Каждый раз, когда потребуется предоставить ссылку на домашнюю страницу, мы будем использовать это имя вместо URL.

НАПИСАНИЕ ПРЕДСТАВЛЕНИЯ

Функция представления получает информацию из запроса, подготавливает данные, необходимые для построения страницы, и возвращает данные браузеру — часто с использованием шаблона, определяющего внешний вид страницы.
Файл views.py в learning_logs был сгенерирован автоматически при выполнении команды python manage.py startapp. На данный момент его содержимое выглядит так:
views.py
from django.shortcuts import render
# Создайте здесь свои представления.
Сейчас файл только импортирует функцию render(), которая генерирует ответ на основании данных, полученных от представлений. Откройте файл представления и добавьте следующий код домашней страницы:
from django.shortcuts import render
def index(request):
"""Домашняя страница приложения Learning Log"""
return render(request, 'learning_logs/index.html')
Если URL запроса совпадает с только что определенной схемой, Django ищет в файле views.py функцию с именем index(), после чего передает этой функции представления объект request. В нашем случае никакая обработка данных для страницы не нужна, поэтому код функции сводится к вызову render(). Функция render() использует два аргумента — исходный объект запроса и шаблон, используемый для построения страницы. Давайте напишем этот шаблон.

НАПИСАНИЕ ШАБЛОНА

Шаблон определяет общий внешний вид страницы, а Django заполняет его соответствующими данными при каждом запросе страницы. Шаблон может обращаться к любым данным, полученным от представления. Так как наше представление домашней страницы никаких данных не предоставляет, шаблон получается относительно простым.
В каталоге learning_logs создайте новый каталог с именем templates. В каталоге templates создайте другой каталог с именем learning_logs. На первый взгляд такая структура кажется избыточной (каталог learning_logs в каталоге templates внутри каталога learning_logs), но созданная таким образом структура будет однозначно интерпретироваться Django даже в контексте большого проекта, состоящего из множества отдельных приложений. Во внутреннем каталоге learning_logs создайте новый файл с именем index.html (таким образом, полное имя файла имеет вид learning_log/learning_logs/templates/learning_logs/index.html). Включите в него следующий текст:
index.html
<p>Learning Log</p>
<p>Learning Log helps you keep track of your learning, for any topic you're
learning about.</p>
Это очень простой файл. Если вы не знакомы с синтаксисом HTML, теги <p></p> обозначают абзацы. Тег <p> открывает абзац, а тег </p> закрывает его. В нашей стра
нице два абзаца: первый содержит заголовок, а второй описывает, что пользователь может сделать с помощью приложения Learning Log.
Теперь при запросе базового URL-адреса проекта http://localhost:8000/ вы увидите только что построенную страницу вместо страницы по умолчанию. Django берет запрошенный URL-адрес и видит, что он совпадает со схемой ''; в этом случае Django вызывает функцию views.index(), что приводит к построению страницы с использованием шаблона, содержащегося в index.html. Полученная страница показана на рис. 18.3.
И хотя может показаться, что для одной страницы этот процесс слишком сложен, такое разделение URL-адресов, представлений и шаблонов работает хорошо. Оно позволяет сосредоточиться на отдельных аспектах проекта, а в более крупных проектах отдельные участники могут сосредоточиться на тех областях, в которых они наиболее сильны. Например, специалист по базам данных может заняться моделями, программист — кодом представления, а веб-дизайнер — шаблонами.
ПРИМЕЧАНИЕ Вы можете получить следующее сообщение об ошибке:
ModuleNotFoundError: No module named 'learning_logs.urls'
В таком случае остановите сервер разработки нажатием клавиш Ctrl+C в терминальном окне, в котором была введена команда runserver. Затем снова введите команду python manage.py runserver. Каждый раз, когда вы сталкиваетесь с подобными ошибками, попробуйте остановить и перезапустить сервер.

ПОСТРОЕНИЕ ДРУГИХ СТРАНИЦ

Теперь, когда вы начали представлять процесс построения страниц, можно переходить к построению проекта Learning Log. Мы создадим две страницы для вывода данных: на одной будет выводиться список всех тем, а на другой — все записи по конкретной теме. Для каждой страницы мы создадим схему URL, напишем функцию представления и создадим шаблон. Но прежде чем переходить к работе, стоит создать базовый шаблон, от которого будут наследовать все шаблоны этого проекта.
Наследование шаблонов
При построении сайта некоторые элементы почти всегда повторяются на каждой странице. Вместо того чтобы встраивать эти элементы непосредственно в страницы, вы можете написать базовый шаблон с повторяющимися элементами; все страницы будут наследовать от этого шаблона. Такое решение позволит сосредоточиться на разработке уникальных аспектов каждой страницы и существенно упростит изменение общего оформления проекта в целом.
Родительский шаблон
Начнем с создания шаблона base.html в одном каталоге с файлом index.html. Этот файл будет содержать элементы, общие для всех страниц; все остальные шаблоны наследуют от base.html. Пока единственным элементом, который должен повторяться на каждой странице, остается заголовок в верхней части страницы. Так как шаблон будет включаться в каждую страницу, преобразуем заголовок в ссылку на домашнюю страницу:
base.html
<p>
❶ <a href="{% url 'learning_logs:index' %}">Learning Log</a>
</p>
❷ {% block content %}{% endblock content %}
Первая часть файла создает абзац с именем проекта, который также работает как ссылка на домашнюю страницу. Для построения ссылки использовался шаблонный тег, обозначенный фигурными скобками и знаками процента {% %}. Шаблонный тег представляет собой блок кода, который генерирует информацию для вывода на странице. В данном примере шаблонный тег {% url 'learning_logs:index' %} генерирует URL-адрес, соответствующий схеме URL, определенной в файле learning_logs/urls.py с именем 'index' . В данном примере learning_logs — пространство имен, а index — схема URL с уникальным именем в этом пространстве имен.
Пространство имен определяется значением, присвоенным app_name в файле learning_logs/urls.py.
В этой простой странице HTML ссылка заключается в якорный тег:
<a href="url_ссылки">текст ссылки</a>
Генерирование URL-адреса шаблонным тегом существенно упрощает актуализацию ссылок. Чтобы изменить URL-адрес в проекте, достаточно изменить схему URL в urls.py, а Django автоматически вставит обновленный URL-адрес при следующем запросе страницы. Каждая страница в проекте будет наследовать от base.html, так что в дальнейшем на каждой странице будет содержаться ссылка на домашнюю страницу.
В точке  вставляется пара тегов block. Блок с именем content резервирует место; информация, попадающая в блок content, будет определяться дочерним шаблоном.
Дочерний шаблон не обязан определять каждый блок в своем родителе, так что в родительских шаблонах можно зарезервировать место для любого количества блоков, а дочерний шаблон будет использовать столько из них, сколько потребуется.
ПРИМЕЧАНИЕ В коде Python почти всегда используются отступы в четыре пробела. Файлы шаблонов обычно имеют больший уровень вложенности, чем файлы Python, поэтому каждый уровень отступа обычно обозначается двумя пробелами. Будьте внимательны и действуйте последовательно.

ДОЧЕРНИЙ ШАБЛОН

Теперь нужно переписать файл index.html так, чтобы он наследовал от base.html. Обновленный файл index.html выглядит так:
index.html
❶ {% extends "learning_logs/base.html" %}
❷ {% block content %}
<p>Learning Log helps you keep track of your learning, for any topic you're
learning about.</p>
❸ {% endblock content %}
Сравнивая этот файл с исходной версией index.html, мы видим, что заголовок Learning Log заменен кодом наследования от родительского шаблона . В первой строке дочернего шаблона должен находиться тег {% extends %}, который сообщает Django, от какого родительского шаблона он наследует. Файл base.html является частью learning_logs, поэтому learning_logs включается в путь к родительскому шаблону. Эта строка извлекает все содержимое из шаблона base.html и позволяет index.html определить, что должно попасть в пространство, зарезервированное блоком content.
Блок content определяется в точке  вставкой тега {% block %} с именем content. Все, что не наследуется от родительского шаблона, попадает в блок content. В данном случае это абзац с описанием проекта Learning Log. В точке  мы сообщаем о том, что определение content завершено, при помощи тега {% endblock content %}. Наличие имени у {% endblock %} не обязательно, но если шаблон увеличится и станет включать несколько блоков, будет полезно сразу видеть, какой именно блок завершается.
Вероятно, вы уже начинаете понимать преимущества наследования шаблонов: в дочерний шаблон достаточно включить информацию, уникальную для этой страницы. Такой подход не только упрощает каждый шаблон, но и значительно упрощает изменение сайта. Чтобы изменить элемент, общий для многих страниц, достаточно изменить элемент в родительском шаблоне. Внесенные изменения будут автоматически перенесены на каждую страницу, наследующую от этого шаблона. В проекте из десятков и сотен страниц такая структура значительно упрощает и ускоряет доработку сайта.
ПРИМЕЧАНИЕ В больших проектах часто создается один родительский шаблон base. html для всего сайта и родительские шаблоны для каждого крупного раздела сайта. Все шаблоны разделов наследуют от base.html, и каждая страница сайта наследует от шаблона раздела. При такой структуре вы сможете легко изменять оформление и поведение сайта в целом, любого его раздела или отдельной страницы. Данная конфигурация сильно повышает эффективность работы и стимулирует разработчика к дальнейшему совершенствованию сайта.

СТРАНИЦА СО СПИСКОМ ТЕМ

Разобравшись с тем, как эффективно организовать построение страниц, мы можем сосредоточиться на следующих двух страницах: списке всех тем и списке записей по одной теме. На странице тем выводится перечень всех тем, созданных пользователями, и это первая страница, на которой нам придется работать с данными.
Схема URL для тем
Сначала нужно определить URL для страницы тем. Обычно в таких случаях выбирается простой фрагмент URL, который отражает суть информации, представленной на странице. Мы воспользуемся словом topics, так что для получения страницы будет использоваться URL http://localhost:8000/topics/. А вот какие изменения следует внести в learning_logs/urls.py:
urls.py
"""Определяет схемы URL для learning_logs."""
...
urlpatterns = [
# Домашняя страница
path('', views.index, name='index'),
# Страница со списком всех тем.
❶ path('topics/', views.topics, name='topics'),
]
Мы просто добавили topics/ в аргумент регулярного выражения, используемый с URL-адресом домашней страницы . Когда Django проверяет запрашиваемый URL-адрес, эта схема совпадет с любым URL-адресом, который состоит из базового URL-адреса и слова topics. Слеш в конце можно включить, а можно не включать, но после слова topics ничего быть не должно, иначе схема не совпадет. Любой запрос с URL-адресом, соответствующим этой схеме, будет передан функции topics() в views.py.

ПРЕДСТАВЛЕНИЕ TOPICS

Функция topics() должна получать данные из базы данных и отправлять их шаблону. Обновленная версия views.py выглядит так:
views.py
from django.shortcuts import render
❶ from .models import Topic
def index(request):
...
❷ def topics(request):
"""Выводит список тем."""
❸ topics = Topic.objects.order_by('date_added')
❹ context = {'topics': topics}
❹ return render(request, 'learning_logs/topics.html', context)
Сначала импортируется модель, связанная с нужными данными . Функции topics() необходим один параметр: объект request, полученный Django от сервера . В точке  выдается запрос к базе данных на получение объектов Topic, отсортированных по атрибуту date_added. Полученный итоговый набор сохраняется в topics.
В точке  определяется контекст, который будет передаваться шаблону. Контекст представляет собой словарь, в котором ключами являются имена, используемые в шаблоне для обращения к данным, а значениями — данные, которые должны передаваться шаблону. В данном случае существует всего одна пара «ключ-значение», которая содержит набор тем, отображаемых на странице. При построении страницы, использующей данные, функции render() передается переменная context, а также объект request и путь к шаблону .

ШАБЛОН TOPICS

Шаблон страницы со списком тем получает словарь context, чтобы шаблон мог использовать данные, предоставленные topics().
Создайте файл с именем topics. html в одном каталоге с index.html. Вывод списка тем в шаблоне осуществляется
следующим образом:
topics.html
{% extends "learning_logs/base.html" %}
{% block content %}
<p>Topics</p>
❶ <ul>
❷ {% for topic in topics %}
❸ <li>{{ topic }}</li>
❹ {% empty %}
<li>No topics have been added yet.</li>
❺ {% endfor %}
❻ </ul>
{% endblock content %}
Сначала тег {% extends %} объявляет о наследовании от base.html, как и в случае с шаблоном index,
после чего открывается блок content. Тело страницы содержит маркированный (bulleted) список введенных тем.
В стандартном языке HTML маркированный список называется неупорядоченным списком и обозначается тегами <ul></ul>.
Список тем начинается в точке .
В точке  находится другой шаблонный тег, эквивалентный циклу for, для перебора списка topics из словаря context.
Код, используемый в шаблоне, отличается от Python некоторыми важными особенностями.
Python использует отступы для обозначения строк, входящих в тело цикла.
В шаблоне каждый цикл for должен снабжаться явным тегом {% endfor %}, обозначающим конец цикла.
Таким образом, в шаблонах часто встречаются циклы следующего вида:
{% for элемент in список %}
действия для каждого элемента
{% endfor %}
В цикле каждая тема должна быть преобразована в элемент маркированного списка.
Чтобы вывести значение переменной в шаблоне, заключите ее имя в двойные фигурные скобки.
Фигурные скобки на странице не появятся; они всего лишь сообщают Django об использовании шаблонной переменной.
Код {{ topic }} в точке  будет заменен значением topic при каждом проходе цикла.
Тег HTML <li></li> обозначает элемент списка. Все, что находится между тегами, в паре тегов <ul></ul>,
будет отображаться как элемент маркированного списка.
В точке  находится шаблонный тег {% empty %}, который сообщает Django, что делать при отсутствии элементов в списке.
В нашем примере выводится сообщение о том, что темы еще не созданы.
Последние две строки завершают цикл for  и маркированный список .
Затем необходимо изменить базовый шаблон и включить ссылку на страницу с темами. Добавьте следующий код в base.html:

base.html
<p>
❶ <a href="{% url 'learning_logs:index' %}">Learning Log</a> -
❷ <a href="{% url 'learning_logs:topics' %}">Topics</a>
</p>
{% block content %}{% endblock content %}
После ссылки на домашнюю страницу  добавляется дефис, после которого вставляется ссылка на страницу тем, которая также
представлена шаблонным тегом {% url %} . Эта строка приказывает Django сгенерировать ссылку, соответствующую схеме URL
с именем 'topics' в learning_logs/urls.py.
Обновив домашнюю страницу в браузере, вы увидите ссылку Topics.

СТРАНИЦЫ ОТДЕЛЬНЫХ ТЕМ

Следующим шагом станет создание страницы для вывода информации по одной теме, с названием темы и всеми записями по этой
теме. Мы снова ОПРЕДЕЛИМ НОВУЮ СХЕМУ URL, НАПИШЕМ ПРЕДСТАВЛЕНИЕ И СОЗДАДИМ ШАБЛОН. Кроме того, на странице со списком
тем каждый элемент маркированного списка будет преобразован в ссылку на соответствующую страницу отдельной темы.

СХЕМА URL ДЛЯ ОТДЕЛЬНЫХ ТЕМ

Схема URL для страницы отдельной темы немного отличается от других схем URL, которые встречались нам ранее, потому что
в ней используется атрибут id темы для обозначения запрашиваемой темы. Например, если пользователь хочет просмотреть
страницу с подробной информацией по теме Chess (id=1), эта страница будет иметь URL-адрес
http://localhost:8000/topics/1/.
Вот как выглядит схема для этого URL-адреса из learning_logs/urls.py:
urls.py
...
urlpatterns = [
...
# Страница с подробной информацией по отдельной теме
path('topics/<int:topic_id>/', views.topic, name='topic'),
]
Рассмотрим строку 'topics/<int:topic_id>/' в этой схеме URL. Первая часть строки сообщает Django, что искать следует
URL-адреса, у которых за базовым адресом идет слово topics. Вторая часть строки, /<int:topic_id>/, описывает целое
число, заключенное между двумя слешами; это целое число сохраняется в аргументе topic_id.
Когда Django находит URL-адрес, соответствующий этой схеме, вызывается функция представления topic(), в аргументе
которой передается значение, хранящееся в topic_id. Значение topic_id используется для получения нужной темы внутри
функции.

ПРЕДСТАВЛЕНИЕ ОТДЕЛЬНОЙ ТЕМЫ

Функция topic() должна получить тему и все связанные с ней записи из базы данных:

views.py
...
❶ def topic(request, topic_id):
"""Выводит одну тему и все ее записи."""
❷ topic = Topic.objects.get(id=topic_id)
❸ entries = topic.entry_set.order_by('-date_added')
❹ context = {'topic': topic, 'entries': entries}
❺ return render(request, 'learning_logs/topic.html', context)

Это первая функция представления, которой требуется параметр, отличный от объекта request. Функция получает значение,
совпавшее с выражением /<int:topic_id>/, и сохраняет его в topic_id . В точке  функция get() используется для
получения темы (по аналогии с тем, как мы это делали в оболочке Django). В точке  загружаются записи, связанные с
данной темой, и они упорядочиваются по значению date_added: знак «минус» перед date_added сортирует результаты в
обратном порядке, то есть самые последние записи будут находиться на первых местах. Тема и записи сохраняются в словаре
context , который передается шаблону topic.html .
ПРИМЕЧАНИЕ Выражения в строках  и , обращающиеся к базе данных за конкретной информацией, называются запросами.
Когда вы пишете подобные запросы для своих проектов, сначала опробуйте их в оболочке Django. Вы сможете проверить
результат намного быстрее, чем если напишете представление и шаблон, а затем проверите результаты в браузере.

ШАБЛОН ОТДЕЛЬНОЙ ТЕМЫ

В шаблоне должно отображаться название темы и текст записей. Также необходимо сообщить пользователю, если по теме еще
не было сделано ни одной записи:

topic.html
{% extends 'learning_logs/base.html' %}
{% block content %}
❶ <p>Topic: {{ topic }}</p>
<p>Entries:</p>
❷ <ul>
❸ {% for entry in entries %}
<li>
❹ <p>{{ entry.date_added|date:'M d, Y H:i' }}</p>
❺ <p>{{ entry.text|linebreaks }}</p>
</li>
❻ {% empty %}
<li>There are no entries for this topic yet.</li>
{% endfor %}
</ul>
{% endblock content %}

Шаблон расширяет base.html, как и для всех страниц проекта. Затем выводится текущая тема  из шаблонной переменной
{{ topic }}. Переменная topic доступна, потому что она включена в словарь context. Затем создается маркированный список
со всеми записями по теме ; перебор записей осуществляется так же, как это делалось ранее для тем .
С каждым элементом списка связываются два значения: временная метка и полный текст каждой записи. Для временной метки 
выводится значение атрибута date_added. В шаблонах Django вертикальная черта (|) представляет фильтр — функцию,
изменяющую значение шаблонной переменной. Фильтр date:'M d, Y H:i' выводит временные метки в формате
January 1, 2018 23:00. Следующая строка выводит полное значение text (вместо первых 50 символов каждой записи).
Фильтр linebreaks  следит за тем, чтобы длинный текст содержал разрывы строк в формате, поддерживаемом браузером
(вместо блока непрерывного текста). В точке  шаблонный тег {% empty %} используется для вывода сообщения
об отсутствии записей.

ССЫЛКИ НА СТРАНИЦЕ

Прежде чем просматривать страницу отдельной темы в браузере, необходимо изменить шаблон списка тем, чтобы каждая тема
вела на соответствующую страницу. Внесите следующие изменения в topics.html:
topics.html
...
{% for topic in topics %}
<li>
<a href="{% url 'learning_logs:topic' topic.id %}">{{ topic }}</a>
</li>
{% empty %}
...
Шаблонный тег URL используется для генерирования ссылки на основании схемы URL из learning_logs с именем 'topic'.
Этой схеме URL необходим аргумент topic_id, поэтому в шаблонный тег URL добавляется атрибут topic.id. Теперь каждая
тема в списке представляет собой ссылку на страницу темы, например http://localhost:8000/topics/1/.
ПРИМЕЧАНИЕ Между topic.id и topic_id существует неочевидное, но важное различие. Выражение topic.id проверяет тему
и получает значение соответствующего идентификатора. Переменная topic_id содержит ссылку на этот идентификатор в коде.
Если вы столкнетесь с ошибками при работе с идентификаторами, убедитесь в том, что эти выражения используются правильно.

Вы начали осваивать построение веб-приложений с использованием инфраструктуры Django.
Вы написали короткую спецификацию проекта, установили Django в виртуальной среде, узнали, как настроить проект,
и проверили правильность настройки. Вы узнали, как создать приложение и как определить модели для представления данных
в вашем приложении. Также были рассмотрены базы данных и вы узнали, как Django упрощает миграцию баз данных после
внесения изменений в модель. Вы научились создавать суперпользователей для административного сайта,
а также использовали административный сайт для ввода исходных данных.
Также в этой главе была представлена оболочка Django, позволяющая работать с данными проекта в терминальном сеансе.
Вы научились определять URL-адреса, создавать функции представления и писать шаблоны для построения страниц сайта.
Наконец, вы применили механизм наследования шаблонов, который упрощает структуру отдельных шаблонов
и модификацию сайта по мере развития проекта.
Далее мы создадим интуитивно понятные, удобные страницы, на которых пользователи смогут добавлять новые темы и
записи, а также редактировать существующие записи без участия административного сайта. Также будет добавлена система
регистрации пользователей, чтобы любой пользователь мог создать учетную запись и вести свой журнал. Собственно,
в этом и заключается сущность веб-приложения — создание функциональности, с которой может взаимодействовать любое
количество пользователей.

УЧЕТНЫЕ ЗАПИСИ ПОЛЬЗОВАТЕЛЕЙ

РЕДАКТИРОВАНИЕ ДАННЫХ

Прежде чем строить систему аутентификации пользователей для создания учетных записей, сначала мы добавим несколько
страниц, на которых пользователи смогут вводить собственные данные. У пользователей появится возможность создавать
новые темы, добавлять новые записи и редактировать записи, сделанные ранее.
В настоящее время данные могут вводиться только суперпользователем на административном сайте. Однако разрешать
пользователям работу на административном сайте явно нежелательно, поэтому мы воспользуемся средствами построения форм
Django для создания страниц, на которых пользователи смогут вводить данные.
Добавление новых тем
Начнем с возможности создания новых тем. Страницы на базе форм добавляются практически так же, как и те страницы,
которые мы уже строили ранее: вы определяете URL, пишете функцию представления и создаете шаблон.
Принципиальное отличие — добавление нового модуля forms.py, содержащего функциональность форм.

ОБЪЕКТ MODELFORM

Любая страница, на которой пользователь может вводить и отправлять информацию, является формой, даже если на первый взгляд она на форму не похожа. Когда пользователь вводит информацию, необходимо проверить, что он ввел корректные данные, а не вредоносный код (например, код для нарушения работы сервера). Затем проверенная информация обрабатывается и сохраняется в нужном месте базы данных. Django автоматизирует большую часть этой работы.
Простейший способ построения форм в Django основан на использовании класса ModelForm, который автоматически строит форму на основании моделей, определенных в главе 18. Ваша первая форма будет создана в файле forms.py, который должен находиться в одном каталоге с models.py:
forms.py
from django import forms
from .models import Topic
❶ class TopicForm(forms.ModelForm):
class Meta:
❷ model = Topic
❸ fields = ['text']
❹ labels = {'text': ''}

Сначала импортируется модуль forms и модель, с которой мы будем работать: Topic.
В точке  определяется класс с именем TopicForm, наследующий от forms.ModelForm.
Простейшая версия ModelForm состоит из вложенного класса Meta, который сообщает Django,
на какой модели должна базироваться форма и какие поля на ней должны находиться.
В точке  форма создается на базе модели Topic, а на ней размещается только поле text .
Код  приказывает Django не генерировать подпись для текстового поля.

URL-АДРЕС ДЛЯ NEW_TOPIC

URL-адрес новой страницы должен быть простым и содержательным, поэтому после того, как пользователь выбрал команду
создания новой темы, он направляется по адресу http://localhost:8000/new_topic/. Ниже приведена схема URL для страницы
new_topic, которая добавляется в learning_logs/urls.py:

urls.py
...
urlpatterns = [
...
# Страница для добавления новой темы
path('new_topic/', views.new_topic, name='new_topic'),
]

Эта схема URL будет отправлять запросы функции представления new_topic(), которую мы сейчас напишем.

ФУНКЦИЯ ПРЕДСТАВЛЕНИЯ NEW_TOPIC

Функция new_topic() должна обрабатывать две разные ситуации: исходные запросы страницы new_topic (в этом случае должна отображаться пустая форма) и обработка данных, отправленных на форме. Затем она должна перенаправить пользователя обратно на страницу topics:
views.py
from django.shortcuts import render, redirect
from .models import Topic
from .forms import TopicForm
...
def new_topic(request):
"""Определяет новую тему."""
❶ if request.method != 'POST':
# Данные не отправлялись; создается пустая форма.
❷ form = TopicForm()
else:
# Отправлены данные POST; обработать данные.
❸ form = TopicForm(data=request.POST)
❹ if form.is_valid():
❺ form.save()
❻ return redirect('learning_logs:topics')
# Вывести пустую или недействительную форму.
❼ context = {'form': form}
return render(request, 'learning_logs/new_topic.html', context)
Мы импортируем класс HttpResponseRedirect, который будет использоваться для перенаправления пользователя к странице
topics после отправки введенной темы. Функция reverse() определяет URL по заданной схеме URL
(то есть Django сгенерирует URL при запросе страницы). Также импортируется только что написанная форма TopicForm.

ЗАПРОСЫ GET И POST

При построении веб-приложений используются два основных типа запросов — GET и POST. Запросы GET используются
для страниц, которые только читают данные с сервера, а запросы POST обычно используются в тех случаях,
когда пользователь должен отправить информацию на форме. Для обработки всех наших форм будет использоваться метод POST
(существуют и другие разновидности запросов, но в нашем проекте они не используются).
Функция new_topic() получает в параметре объект запроса. Когда пользователь впервые запрашивает эту страницу,
его браузер отправляет запрос GET. Когда пользователь уже заполнил и отправил форму, его браузер отправляет запрос POST.
В зависимости от типа запроса мы определяем, запросил ли пользователь пустую форму (запрос GET) или предлагает
обработать заполненную форму (запрос POST).
Метод запроса — GET или POST — проверяется в точке .
Если метод запроса отличен от POST, вероятно, используется запрос GET, поэтому необходимо вернуть пустую форму
(даже если это запрос другого типа, это все равно безопасно). Мы создаем экземпляр TopicForm , сохраняем его в
переменной form и отправляем форму шаблону в словаре context .
Так как при создании TopicForm аргументы не передавались, Django создает пустую форму, которая заполняется пользователем.
Если используется метод запроса POST, выполняется блок else, который обрабатывает данные, отправленные в форме.
Мы создаем экземпляр TopicForm  и передаем ему данные, введенные пользователем, хранящиеся в request.POST.
Возвращаемый объект form содержит информацию, отправленную пользователем.
Отправленную информацию нельзя сохранять в базе данных до тех пор, пока она не будет проверена .
Функция is_valid() проверяет, что все обязательные поля были заполнены (все поля формы по умолчанию являются
обязательными), а введенные данные соответствуют типам полей — например, что длина текста меньше 200 символов,
как было указано в файле models.py в главе 18. Автоматическая проверка избавляет нас от большого объема работы.
Если все данные действительны, можно вызвать метод save() , который записывает данные из формы в базу данных.
После того как данные будут сохранены, страницу можно покинуть.
Мы используем вызов redirect()  для перенаправления браузера на страницу topics, на которой пользователь увидит
только что введенную им тему в общем списке тем.
Переменная context определяется в конце функции представления , а страница строится на базе шаблона new_topic.html,
который будет создан на следующем шаге. Код размещается за пределами любых блоков if; он выполняется при создании
пустой формы, а также при определении того, что отправленная форма была недействительной.
Недействительная форма включает стандартные сообщения об ошибках, чтобы помочь пользователю передать действительные данные.

ШАБЛОН NEW_TOPIC

Теперь создадим новый шаблон с именем new_topic.html для отображения только что созданной формы:
new_topic.html
{% extends "learning_logs/base.html" %}
{% block content %}
<p>Add a new topic:</p>
❶ <form action="{% url 'learning_logs:new_topic' %}" method='post'>
❷ {% csrf_token %}
❸ {{ form.as_p }}
❹ <button name="submit">add topic</button>
</form>
{% endblock content %}
Этот шаблон расширяет base.html, поэтому он имеет такую же базовую структуру, как и остальные страницы Learning Log. В точке  определяется форма HTML. Аргумент action сообщает серверу, куда передавать данные, отправленные формой; в данном случае данные возвращаются функции представления new_topic(). Аргумент method приказывает браузеру отправить данные в запросе типа POST.
Django использует шаблонный тег {% csrf_token %}  для предотвращения попыток получения несанкционированного доступа к серверу (атаки такого рода называются межсайтовой подделкой запросов). В точке  отображается форма; это наглядный пример того, как легко в Django выполняются такие стандартные операции, как отображение формы. Чтобы автоматически создать все поля, необходимые для отображения формы, достаточно включить шаблонную переменную {{ form.as_p }}. Модификатор as_p приказывает Django отобразить все элементы формы в формате абзацев — это простой способ аккуратного отображения формы.
Django не создает кнопку отправки данных для форм, поэтому мы определяем ее в точке .
Создание ссылки на страницу new_topic
Далее ссылка на страницу new_topic создается на странице topics:
topics.html
{% extends "learning_logs/base.html" %}
{% block content %}
<p>Topics</p>
<ul>
...
</ul>
<a href="{% url 'learning_logs:new_topic' %}">Add a new topic:</a>
{% endblock content %}

ДОБАВЛЕНИЕ НОВЫХ ЗАПИСЕЙ

Теперь, когда пользователь может добавлять новые темы, он также захочет добавлять новые записи. Мы снова определим URL,
напишем новую функцию и шаблон и создадим ссылку на страницу. Но сначала нужно добавить в forms.py еще один класс.

КЛАСС ENTRYFORM

Мы должны создать форму, связанную с моделью Entry, но более специализированную по сравнению с TopicForm:

forms.py
from django import forms
from .models import Topic, Entry
class TopicForm(forms.ModelForm):
...
class EntryForm(forms.ModelForm):
class Meta:
model = Entry
fields = ['text']
❶ labels = {'text': 'Entry:'}
❷ widgets = {'text': forms.Textarea(attrs={'cols': 80})}

Сначала в команду import к Topic добавляется Entry.
Новый класс EntryForm наследует от forms.ModelForm и содержит вложенный класс Meta с указанием модели,
на которой он базируется, и поле, включаемое на форму. Полю 'text' снова назначается пустая надпись .
В точке  включается атрибут widgets. Виджет (widget) представляет собой элемент формы HTML:
однострочное или многострочное текстовое поле, раскрывающийся список и т. д.
Включая атрибут widgets, вы можете переопределить виджеты, выбранные Django по умолчанию.
Приказывая Django использовать элемент forms.Textarea, мы настраиваем виджет ввода для поля 'text',
чтобы ширина текстовой области составляла 80 столбцов вместо значения по умолчанию 40.
У пользователя будет достаточно места для создания содержательных записей.

URL-АДРЕС ДЛЯ NEW_ENTRY

Необходимо включить аргумент topic_id в URL-адрес для создания новой записи, потому что запись должна ассоциироваться с конкретной темой. Вот как выглядит URL, который мы добавляем в learning_logs/urls.py:
urls.py
...
urlpatterns = [
...
# Страница для добавления новой записи
path('new_entry/<int:topic_id>/', views.new_entry, name='new_entry'),
]
Эта схема URL соответствует любому URL-адресу в форме http://localhost:8000/new_entry/id/, где id — число, равное идентификатору темы. Код <int:topic_id> захватывает числовое значение и сохраняет его в переменной topic_id. При запросе URL-адреса, соответствующего этой схеме, Django передает запрос и идентификатор темы функции представления new_entry().
Функция представления new_entry()
Функция представления new_entry очень похожа на функцию добавления новой темы. Включите следующий код в файл views.py:
views.py
from django.shortcuts import render, redirect
from .models import Topic
from .forms import TopicForm, EntryForm
...
def new_entry(request, topic_id):
"""Добавляет новую запись по конкретной теме."""
❶ topic = Topic.objects.get(id=topic_id)
❷ if request.method != 'POST':
# Данные не отправлялись; создается пустая форма.
❸ form = EntryForm()
else:
# Отправлены данные POST; обработать данные.
❹ form = EntryForm(data=request.POST)
if form.is_valid():
❺ new_entry = form.save(commit=False)
❻ new_entry.topic = topic
new_entry.save()
❼ return redirect('learning_logs:topic', topic_id=topic_id)
# Вывести пустую или недействительную форму.
context = {'topic': topic, 'form': form}
return render(request, 'learning_logs/new_entry.html', context)
Мы обновляем команду import и включаем в нее только что созданный класс EntryForm. Определение new_entry() содержит параметр topic_id для сохранения полученного значения из URL. Идентификатор темы понадобится для отображения страницы и обработки данных формы, поэтому мы используем topic_id для получения правильного объекта темы .
В точке  проверяется метод запроса: POST или GET. Блок if выполняется для запроса GET, и мы создаем пустой экземпляр EntryForm .
Для метода запроса POST мы обрабатываем данные, создавая экземпляр EntryForm, заполненный данными POST из объекта request . Затем проверяется корректность данных формы. Если данные корректны, необходимо задать атрибут topic объекта записи перед сохранением его в базе данных. При вызове save() мы включаем аргумент commit=False  для того, чтобы создать новый объект записи и сохранить его в new_entry, не сохраняя пока в базе данных. Мы присваиваем атрибуту topic объекта new_entry тему, прочитанную из базы данных в начале функции , после чего вызываем save() без аргументов. В результате запись сохраняется в базе данных с правильно ассоциированной темой.
Вызов redirect() в точке  получает два аргумента — имя представления, которому передается управление, и аргумент для функции представления. В данном случае происходит перенаправление функции topic(), которой должен передаваться аргумент topic_id. Вызов перенаправляет пользователя на страницу темы, для которой была создана запись, и пользователь видит новую запись в списке записей.
В конце функции создается словарь context, а страница строится на базе шаблона new_entry.html. Этот код выполняется для пустой формы или для отправленной формы, которая была определена как недействительная.

ШАБЛОН NEW_ENTRY

Как видно из следующего кода, шаблон new_entry похож на шаблон new_topic:
new_entry.html
{% extends "learning_logs/base.html" %}
{% block content %}
❶ <p><a href="{% url 'learning_logs:topic' topic.id %}">{{ topic }}</a></p>
<p>Add a new entry:</p>
❷ <form action="{% url 'learning_logs:new_entry' topic.id %}" method='post'>
{% csrf_token %}
{{ form.as_p }}
<button name='submit'>add entry</button>
</form>
{% endblock content %}
В начале страницы выводится тема , чтобы пользователь мог видеть, в какую тему добавляется новая запись. Тема также служит ссылкой на главную страницу этой темы.
Аргумент action формы включает значение topic_id из URL, чтобы функция представления могла связать новую запись с правильной темой . В остальном этот шаблон почти не отличается от new_topic.html.

СОЗДАНИЕ ССЫЛКИ НА СТРАНИЦУ NEW_ENTRY

Затем необходимо создать ссылку на страницу new_entry на каждой странице темы:
topic.html
{% extends "learning_logs/base.html" %}
{% block content %}
<p>Topic: {{ topic }}</p>
<p>Entries:</p>
<p>
<a href="{% url 'learning_logs:new_entry' topic.id %}">add new entry</a>
</p>
<ul>
...
</ul>
{% endblock content %}

Ссылка добавляется перед выводом записей, потому что добавление новой записи является самым частым действием
на этой странице.
Теперь пользователь может добавить сколько угодно новых тем и новых записей по каждой теме.

РЕДАКТИРОВАНИЕ ЗАПИСЕЙ

А теперь мы создадим страницу, на которой пользователи смогут редактировать ранее добавленные записи.

URL-АДРЕС ДЛЯ EDIT_ENTRY

В URL-адресе страницы должен передаваться идентификатор редактируемой записи. В файл learning_logs/urls.py для этого вносятся следующие изменения:
urls.py
...
urlpatterns = [
...
# Страница для редактирования записи
path('edit_entry/<int:entry_id>/', views.edit_entry, name='edit_entry'),
]
Идентификатор, переданный в URL (например, http://localhost:8000/edit_entry/1/), сохраняется в параметре entry_id. Схема URL отправляет запросы, соответствующие этому формату, функции представления edit_entry().
Функция представления edit_entry()
Когда страница edit_entry получает запрос GET, edit_entry() возвращает форму для редактирования записи.
При получении запроса POST с отредактированной записью страница сохраняет измененный текст в базе данных:
views.py
from django.shortcuts import render, redirect
from .models import Topic, Entry
from .forms import TopicForm, EntryForm
...
def edit_entry(request, entry_id):
"""Редактирует существующую запись."""
❶ entry = Entry.objects.get(id=entry_id)
topic = entry.topic
if request.method != 'POST':
# Исходный запрос; форма заполняется данными текущей записи.
❷ form = EntryForm(instance=entry)
else:
# Отправка данных POST; обработать данные.
❸ form = EntryForm(instance=entry, data=request.POST)
if form.is_valid():
❹ form.save()
❺ return redirect('learning_logs:topic', topic_id=topic.id)
context = {'entry': entry, 'topic': topic, 'form': form}
return render(request, 'learning_logs/edit_entry.html', context)
Сначала необходимо импортировать модель Entry. В точке  мы получаем объект записи, который пользователь хочет изменить,
и тему, связанную с этой записью. В блоке if, который выполняется для запроса GET, создается экземпляр EntryForm с
аргументом instance=entry .
Этот аргумент приказывает Django создать форму, заранее заполненную информацией из существующего объекта записи.
Пользователь видит свои существующие данные и может отредактировать их.
При обработке запроса POST передаются аргументы instance=entry и data=request.POST .
Они приказывают Django создать экземпляр формы на основании информации существующего объекта записи,
обновленный данными из request.POST.
Затем проверяется корректность данных формы. Если данные корректны, следует вызов save() без аргументов .
Далее происходит перенаправление на страницу темы , и пользователь видит обновленную версию
отредактированной им записи.
Если отображается исходная форма для редактирования записи или если отправленная форма недействительна,
создается словарь context, а страница строится на базе шаблона edit_entry.html.

ШАБЛОН EDIT_ENTRY

Шаблон edit_entry.html очень похож на new_entry.html:
edit_entry.html
{% extends "learning_logs/base.html" %}
{% block content %}
<p><a href="{% url 'learning_logs:topic' topic.id %}">{{ topic }}</a></p>
<p>Edit entry:</p>
❶ <form action="{% url 'learning_logs:edit_entry' entry.id %}" method='post'>
{% csrf_token %}
{{ form.as_p }}
❷ <button name="submit">save changes</button>
</form>
{% endblock content %}
В точке  аргумент action отправляет форму функции edit_entry() для обработки. Идентификатор записи включается как аргумент в тег {% url %} , чтобы функция представления могла изменить правильный объект записи. Кнопка отправки данных создается с текстом, который напоминает пользователю, что он сохраняет изменения, а не создает новую запись .

СОЗДАНИЕ ССЫЛКИ НА СТРАНИЦУ EDIT_ENTRY

Теперь необходимо включить ссылку на страницу edit_entry в каждую тему на странице со списком тем:
topic.html
...
{% for entry in entries %}
<li>
<p>{{ entry.date_added|date:'M d, Y H:i' }}</p>
<p>{{ entry.text|linebreaks }}</p>
<p>
<a href="{% url 'learning_logs:edit_entry' entry.id %}">Edit entry</a>
</p>
</li>
...
После даты и текста каждой записи включается ссылка редактирования. Мы используем шаблонный тег {% url %} для
определения схемы URL из именованной схемы edit_entry и идентификатора текущей записи в цикле (entry.id).
Текст ссылки "edit entry" выводится после каждой записи на странице. На рис. 19.3 показано, как выглядит страница
со списком тем с этими ссылками.
Приложение Learning Log уже сейчас содержит большую часть необходимой функциональности.
Пользователи могут добавлять темы и записи, а также читать любые записи по своему усмотрению.
В этом разделе мы реализуем систему регистрации пользователей, чтобы любой желающий мог создать свою учетную запись
в Learning Log и ввести собственный набор тем и записей.

СОЗДАНИЕ УЧЕТНЫХ ЗАПИСЕЙ ПОЛЬЗОВАТЕЛЕЙ

В этом разделе мы создадим систему регистрации и авторизации пользователей, чтобы люди могли создать учетную запись,
начать и завершать сеанс работы с приложением. Для всей функциональности, относящейся к работе с пользователями,
будет создано отдельное приложение. Мы также слегка изменим модель Topic, чтобы каждая тема была связана с
конкретным пользователем.

ПРИЛОЖЕНИЕ USERS

Начнем с создания нового приложения users командой startapp:
(ll_env)learning_log$ python manage.py startapp users
(ll_env)learning_log$ ls
❶ db.sqlite3 learning_log learning_logs ll_env manage.py users
(ll_env)learning_log$ ls users
❷ __init__.py admin.py apps.py migrations models.py tests.py views.py
Эта команда создает новый каталог с именем users , структура которого повторяет структуру каталогов приложения learning_logs .
Добавление пользователей в settings.py
Новое приложение необходимо добавить в settings.py:
settings.py
...
INSTALLED_APPS = [
# Мои приложения
'learning_logs',
'users',
# Приложения django по умолчанию.
...
]
...
Django включает приложение users в общий проект.
Включение URL-адресов из users
Затем необходимо изменить корневой файл urls.py, чтобы он включал URL-адреса, написанные для приложения users:
urls.py
from django.contrib import admin
from django.urls import path, include
urlpatterns = [
path('admin/', admin.site.urls),
path('users/', include('users.urls')),
path('', include('learning_logs.urls')),
]
Добавим строку для включения файла urls.py из users. Эта строка будет соответствовать любому URL-адресу,
начинающемуся со слова users, например http://localhost:8000/users/login/.

СТРАНИЦА ВХОДА

Начнем с реализации страницы входа. Мы воспользуемся стандартным представлением login, которое предоставляет Django, так что шаблон URL выглядит немного иначе. Создайте новый файл urls.py в каталоге learning_log/users/ и добавьте в него следующий код:
urls.py
"""Определяет схемы URL для пользователей"""
from django.urls import path, include
❶ app_name = 'users'
urlpatterns = [
# Включить URL авторизации по умолчанию.
❷ path('', include('django.contrib.auth.urls')),
]
Сначала импортируется функция path, а затем функция include для включения аутентификационных URL-адресов по умолчанию, определенных Django. Эти URL-адреса по умолчанию включают именованные схемы, такие как 'login' и 'logout'. Переменной app_name присваивается значение 'users', чтобы инфраструктура Django могла отличить эти URL-адреса от URL-адресов, принадлежащих другим приложениям . Даже URL-адреса по умолчанию, предоставляемые Djano, при включении в файл urls.py приложения users будут доступны через пространство имен users.
Схема страницы входа соответствует URL http://localhost:8000/users/login/ . Когда Django читает этот URL-адрес, слово users указывает, что следует обратиться к users/urls.py, а login сообщает о том, что запросы должны отправляться представлению login по умолчанию.
Шаблон login
Когда пользователь запрашивает страницу входа, Django использует свое представление login по умолчанию, но мы все равно должны предоставить шаблон для этой страницы. Аутентификационные представления по умолчанию ищут шаблоны в каталоге с именем registration, поэтому вы должны создать этот каталог. В каталоге learning_log/users/ создайте каталог с именем templates, а внутри него — еще один каталог с именем registration. Вот как выглядит шаблон login.html, который должен находиться в learning_log/users/templates/registration/:
login.html
{% extends "learning_logs/base.html" %}
{% block content %}
❶ {% if form.errors %}
<p>Your username and password didn't match. Please try again.</p>
{% endif %}
❷ <form method="post" action="{% url 'users:login' %}">
{% csrf_token %}
❸ {{ form.as_p }}
❹ <button name="submit">log in</button>
❺ <input type="hidden" name="next"
value="{% url 'learning_logs:index' %}" />
</form>
{% endblock content %}
Шаблон расширяет base.html, чтобы страница входа по оформлению и поведению была похожа на другие страницы сайта. Обратите внимание: шаблон в одном приложении может расширять шаблон из другого приложения.
Если у формы установлен атрибут errors, выводится сообщение об ошибке . В нем говорится, что комбинация имени пользователя и пароля не соответствует информации, хранящейся в базе данных.
Мы хотим, чтобы представление обработало форму, поэтому аргументу action присваивается URL страницы входа . Представление отправляет форму шаблону, мы должны вывести форму  и добавить кнопку отправки данных . В точке  включается скрытый элемент формы 'next'; аргумент value сообщает Django, куда перенаправить пользователя после успешно выполненного входа. В нашем случае пользователь возвращается обратно на домашнюю страницу.

СОЗДАНИЕ ССЫЛКИ НА СТРАНИЦУ ВХОДА

Добавим ссылку на страницу входа в base.html, чтобы она присутствовала на каждой странице. Ссылка не должна отображаться, если пользователь уже прошел процедуру входа, поэтому она вкладывается в тег {% if %}:
base.html
<p>
<a href="{% url 'learning_logs:index' %}">Learning Log</a> -
<a href="{% url 'learning_logs:topics' %}">Topics</a> -
❶ {% if user.is_authenticated %}
❷ Hello, {{ user.username }}.
{% else %}
❸ <a href="{% url 'users:login' %}">log in</a>
{% endif %}
</p>
{% block content %}{% endblock content %}
В системе аутентификации Django в каждом шаблоне доступна переменная user, которая всегда имеет атрибут
is_authenticated: атрибут равен True, если пользователь прошел проверку, и False в противном случае.
Это позволяет вам выводить разные сообщения для проверенных и непроверенных пользователей.
В данном случае мы выводим приветствие для пользователей, выполнивших вход . У проверенных пользователей устанавливается дополнительный атрибут username, который обеспечит личную настройку приветствия и напомнит пользователю о том, что вход был выполнен . В точке  выводится ссылка на страницу входа для пользователей, которые еще не прошли проверку.

ИСПОЛЬЗОВАНИЕ СТРАНИЦЫ ВХОДА

Учетная запись пользователя уже создана; попробуем ввести данные и посмотрим, работает ли страница. Откройте страницу http://localhost:8000/admin/. Если вы все еще работаете с правами администратора, найдите ссылку выхода в заголовке и щелкните на ней.
После выхода перейдите по адресу http://localhost:8000/users/login/. На экране должна появиться страница входа, похожая на рис. 19.4. Введите имя пользователя и пароль, заданные ранее, и вы снова должны оказаться на странице со списком. В заголовке страницы должно выводиться сообщение с указанием имени пользователя.

ВЫХОД

Теперь необходимо предоставить пользователям возможность выхода из приложения. Мы включим в base.html ссылку для выхода
пользователя; при щелчке на этой ссылке открывается страница, подтверждающая, что выход был выполнен успешно.

ДОБАВЛЕНИЕ ССЫЛКИ ДЛЯ ВЫХОДА

Теперь нужно создать ссылку для выхода. Мы добавим ее в файл base.html, чтобы она была доступна на каждой странице, и включим в секцию {% if user.is_authenticated %}, чтобы ссылка была видна только пользователям, уже выполнившим вход:
base.html
...
{% if user.is_authenticated %}
Hello, {{ user.username }}.
<a href="{% url 'users:logout' %}">log out</a>
{% else %}
...
По умолчанию схеме URL для выхода назначается имя 'logout'.

СТРАНИЦА ПОДТВЕРЖДЕНИЯ ВЫХОДА

Пользователь должен знать, что выход прошел успешно, поэтому представление по умолчанию для выхода строит страницу на базе шаблона logged_out.html, который мы сейчас создадим. Он представляет простую страницу с уведомлением о том, что пользователь вышел из сеанса работы с приложением. Сохраните файл в каталоге templates/registration — в том же каталоге, в котором был сохранен файл login.html:
logged_out.html
{% extends "learning_logs/base.html" %}
{% block content %}
<p>You have been logged out. Thank you for visiting!</p>
{% endblock content %}
Ничего другого на этой странице быть не должно, потому что base.html предоставляет ссылки на домашнюю страницу и страницу входа на случай, если пользователь захочет вернуться к какой-либо из этих страниц.
На рис. 19.5 изображена страница выхода так, как ее видит пользователь, выполнивший вход. Оформление страницы минимально, потому что сейчас нас в первую очередь интересует работа сайта. Когда необходимые функции заработают, можно переходить к стилевому оформлению сайта и приданию ему более профессионального вида.

СТРАНИЦА РЕГИСТРАЦИИ

Теперь мы построим страницу для регистрации новых пользователей. Для этой цели мы используем класс Django UserCreationForm, но напишем собственную функцию представления и шаблон.

URL-АДРЕС РЕГИСТРАЦИИ

Следующий код предоставляет шаблон URL для страницы регистрации — также в файле users/urls.py:
urls.py
""" Определяет схемы URL для пользователей. """
from django.urls import path, include
from . import views
app_name = 'users'
urlpatterns = [
# Включить URL авторизации по умолчанию.
path('', include('django.contrib.auth.urls')),
# Страница регистрации.
path('register/', views.register, name='register'),
]
Мы импортируем модуль views из users; этот модуль необходим, потому что мы пишем собственное представление для страницы регрессии. Шаблон соответствует URL http://localhost:8000/users/register/ и отправляет запросы функции register(), которую мы сейчас напишем.

ФУНКЦИЯ ПРЕДСТАВЛЕНИЯ REGISTER()

Функция представления register() должна вывести пустую форму регистрации при первом запросе страницы регистрации,
а затем обработать заполненную форму регистрации при отправке данных. Если регистрация прошла успешно,
функция также должна выполнить вход для нового пользователя. Включите следующий код в users/views.py:
views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login
from django.contrib.auth.forms import UserCreationForm
def register(request):
"""Регистрирует нового пользователя."""
if request.method != 'POST':
# Выводит пустую форму регистрации.
❶ form = UserCreationForm()
else:
# Обработка заполненной формы.
❷ form = UserCreationForm(data=request.POST)
❸ if form.is_valid():
❹ new_user = form.save()
# Выполнение входа и перенаправление на домашнюю страницу.
❺ login(request, new_user)
❻ return redirect('learning_logs:index')
# Вывести пустую или недействительную форму.
context = {'form': form}
return render(request, 'users/register.html', context)
Сначала импортируются функции render() и redirect(). Затем мы импортируем функцию login() для выполнения входа пользователя, если регистрационная информация верна. Также импортируется класс UserCreationForm по умолчанию. В функции register() мы проверяем, отвечает ли функция на запрос POST. Если нет, создается экземпляр UserCreationForm, не содержащий исходных данных .
В случае ответа на запрос POST создается экземпляр UserCreationForm, основанный на отправленных данных . Мы проверяем, что данные верны ; в данном случае что имя пользователя содержит правильные символы, пароли совпадают, а пользователь не пытается вставить вредоносные конструкции в отправленные данные.
Если отправленные данные верны, мы вызываем метод save() формы для сохранения имени пользователя и хеша пароля в базе данных . Метод save() возвращает только что созданный объект пользователя, который сохраняется в new_user. После того как информация пользователя будет сохранена, мы выполняем вход; этот процесс состоит из двух шагов: сначала вызывается функция login() с объектами request и new_user , которая создает действительный сеанс для нового пользователя. Наконец, пользователь перенаправляется на домашнюю страницу , где приветствие в заголовке сообщает о том, что регистрация прошла успешно.
В конце функции строится страница, которая будет либо пустой формой, либо отправленной формой, содержащей недействительные данные.

ШАБЛОН РЕГИСТРАЦИИ

Шаблон страницы регистрации похож на шаблон страницы входа. Проследите за тем, чтобы он был сохранен в одном каталоге с login.html:
register.html
{% extends "learning_logs/base.html" %}
{% block content %}
<form method="post" action="{% url 'users:register' %}">
{% csrf_token %}
{{ form.as_p }}
<button name="submit">register</button>
<input type="hidden" name="next" value="{% url 'learning_logs:index' %}" />
</form>
{% endblock content %}
Мы снова используем метод as_p, чтобы инфраструктура Django могла правильно отобразить все поля формы, включая все сообщения об ошибках, если форма была заполнена неправильно.

СОЗДАНИЕ ССЫЛКИ НА СТРАНИЦУ РЕГИСТРАЦИИ

Следующий шаг — добавление кода для вывода ссылки на страницу регистрации для любого пользователя, еще не выполнившего вход:
base.html
...
{% if user.is_authenticated %}
Hello, {{ user.username }}.
<a href="{% url 'users:logout' %}">log out</a>
{% else %}
<a href="{% url 'users:register' %}">Register</a> -
<a href="{% url 'users:login' %}">log in</a>
{% endif %}
...
Теперь пользователи, выполнившие вход, получат персональное приветствие и ссылку для выхода. Другие пользователи видят ссылку на страницу регистрации и ссылку для входа. Проверьте страницу регистрации, создав несколько учетных записей с разными именами пользователей.
В следующем разделе доступ к некоторым страницам будет ограничен, чтобы страницы были доступны только для зарегистрированных пользователей. Также необходимо позаботиться о том, чтобы каждая тема принадлежала конкретному пользователю.

РЕДАКТИРОВАНИЕ ДАННЫХ

Пользователь должен иметь возможность вводить данные, принадлежащие только ему лично. Мы создадим систему, которая будет определять, какому пользователю принадлежат те или иные данные, и будет ограничивать доступ к страницам, чтобы пользователь мог работать только с принадлежащими ему данными.
В этом разделе мы изменим модель Topic, чтобы каждая тема принадлежала конкретному пользователю. При этом также автоматически решается проблема с записями, так как каждая запись принадлежит конкретной теме. Начнем с ограничения доступа к страницам.

ОГРАНИЧЕНИЕ ДОСТУПА С ИСПОЛЬЗОВАНИЕМ @LOGIN_REQUIRED

Django позволяет легко ограничить доступ к определенным страницам для пользователей, выполнивших вход, с помощью декоратора @login_required. Декоратор (decorator) представляет собой директиву, размещенную непосредственно перед определением функции, применяемую к функции перед ее выполнением и влияющую на поведение кода. Рассмотрим пример.

ОГРАНИЧЕНИЕ ДОСТУПА К СТРАНИЦАМ ТЕМ

Каждая тема будет принадлежать пользователю, поэтому только зарегистрированные пользователи смогут запрашивать страницы тем. Добавьте следующий код в learning_logs/views.py:
views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from .models import Topic, Entry
...
@login_required
def topics(request):
"""Выводит все темы."""
...
Сначала импортируется функция login_required(). Мы применяем login_required() как декоратор для функции представления topics(), для чего перед именем login_required() ставится знак @; он сообщает Python, что этот код должен выполняться перед кодом topics().
Код login_required() проверяет, вошел ли пользователь в систему, и Django запускает код topics() только при выполнении этого условия. Если же пользователь не выполнил вход, он перенаправляется на страницу входа.
Чтобы перенаправление работало, необходимо внести изменения settings.py и сообщить Django, где искать страницу входа. Добавьте следующий фрагмент в самый конец settings.py:
settings.py
...
# Мои настройки
LOGIN_URL = '/users/login/'
Когда пользователь, не прошедший проверку, запрашивает страницу, защищенную декоратором @login_required, Django отправляет пользователя на URL-адрес, определяемый LOGIN_URL в settings.py.
Чтобы протестировать эту возможность, завершите сеанс в любой из своих учетных записей и вернитесь на домашнюю страницу. Щелкните на ссылке Topics, которая должна направить вас на страницу входа. Выполните вход с любой из своих учетных записей, на домашней странице снова щелкните на ссылке Topics. На этот раз вы получите доступ к странице со списком тем.
Ограничение доступа в Learning Log
Django упрощает ограничение доступа к страницам, но вы должны решить, какие страницы следует защищать. Лучше сначала подумать, к каким страницам можно разрешить неограниченный доступ, а затем ограничить его для всех остальных страниц. Снять излишние ограничения несложно, причем это куда менее рискованно, чем оставлять действительно важные страницы без ограничения доступа.
В приложении Learning Log мы оставим неограниченный доступ к домашней странице, странице регистрации и странице выхода. Доступ ко всем остальным страницам будет ограничен.
Вот как выглядит файл learning_logs/views.py с декораторами @login_required, примененными к каждому представлению, кроме index():

views.py
...
@login_required
def topics(request):
...
@login_required
def topic(request, topic_id):
...
@login_required
def new_topic(request):
...
@login_required
def new_entry(request, topic_id):
...
@login_required
def edit_entry(request, entry_id):
...
Попробуйте обратиться к любой из этих страниц без выполнения входа: вы будете перенаправлены обратно на страницу входа. Кроме того, вы не сможете щелкать на ссылках на такие страницы, как new_topic. Но если ввести URL http://localhost:8000/new_topic/, вы будете перенаправлены на страницу входа. Ограничьте доступ ко всем URL-адресам, связанным с личными данными пользователей.
Связывание данных с конкретными пользователями
Теперь данные, отправленные пользователем, необходимо связать с тем пользователем, который их отправил. Связь достаточно установить только с данными, находящимися на высшем уровне иерархии, а низкоуровневые данные последуют за ними автоматически. Например, в приложении Learning Log на высшем уровне находятся темы, а каждая запись связывается с некоторой темой. Если каждая тема принадлежит конкретному пользователю, мы сможем отследить владельца каждой записи в базе данных.
Изменим модель Topic и добавим отношение внешнего ключа к пользователю. После этого необходимо провести миграцию базы данных. Наконец, необходимо изменить некоторые представления, чтобы в них отображались только данные, связанные с текущим пользователем.
Изменение модели Topic
В файле models.py изменяются всего две строки:
models.py
from django.db import models
from django.contrib.auth.models import User

class Topic(models.Model):
"""Тема, которую изучает пользователь"""
text = models.CharField(max_length=200)
date_added = models.DateTimeField(auto_now_add=True)
owner = models.ForeignKey(User, on_delete=models.CASCADE)
def __str__(self):
"""Возвращает строковое представление модели."""
return self.text
class Entry(models.Model):
...
Сначала модель User импортируется из django.contrib.auth. Затем в Topic добавляется поле owner, используемое в отношении внешнего ключа к модели User. Если пользователь удаляется, все темы, связанные с этим пользователем, также будут удалены.

ИДЕНТИФИКАЦИЯ СУЩЕСТВУЮЩИХ ПОЛЬЗОВАТЕЛЕЙ

При проведении миграции Django модифицирует базу данных, чтобы в ней хранилась связь между каждой темой и пользователем. Для выполнения миграции Django необходимо знать, с каким пользователем должна быть связана каждая существующая тема. Проще всего связать все существующие темы с одним пользователем, например суперпользователем. Но для этого сначала необходимо узнать идентификатор этого пользователя.
Просмотрим идентификаторы всех пользователей, созданных до настоящего момента. Запустите сеанс оболочки Django и введите следующие команды:
(ll_env)learning_log$ python manage.py shell
❶ >>> from django.contrib.auth.models import User
❷ >>> User.objects.all()
<QuerySet [<User: ll_admin>, <User: eric>, <User: willie>]>
❸ >>> for user in User.objects.all():
... print(user.username, user.id)
...
ll_admin 1
eric 2
willie 3
>>>
В точке  в сеанс оболочки импортируется модель User. После этого просматриваются все пользователи, созданные до настоящего момента . В выходных данных перечислены три пользователя: ll_admin, eric и willie.
В точке  перебирается список пользователей, и для каждого пользователя выводится его имя и идентификатор. Когда Django спросит, с каким пользователем связать существующие темы, мы используем один из этих идентификаторов.

Миграция базы данных
Зная значение идентификатора, можно провести миграцию базы данных. Когда вы это делаете, Python предлагает связать модель Topic с конкретным владельцем временно или добавить в models.py значение по умолчанию, которое сообщит, как следует поступить. Выберите вариант 1:
❶ (ll_env)learning_log$ python manage.py makemigrations learning_logs
❷ You are trying to add a non-nullable field 'owner' to topic without a default;
we can't do that (the database needs something to populate existing rows).
❸ Please select a fix:
1) Provide a one-off default now (will be set on all existing rows with a
null value for this column)
2) Quit, and let me add a default in models.py
❹ Select an option: 1
❺ Please enter the default value now, as valid Python
The datetime and django.utils.timezone modules are available, so you can do
e.g. timezone.now
Type 'exit' to exit this prompt
❻ >>> 1
Migrations for 'learning_logs':
learning_logs/migrations/0003_topic_owner.py
- Add field owner to topic
(ll_env)learning_log$
Сначала выдается команда makemigrations . В ее выходных данных  Django сообщает, что мы пытаемся добавить обязательное поле (значения которого отличны от null) в существующую модель (topic) без указания значения по умолчанию. Django предоставляет два варианта : мы можем либо указать значение по умолчанию прямо сейчас, либо завершить выполнение программы и добавить значение по умолчанию в models.py. В точке  выбирается первый вариант. Тогда Django запрашивает значение по умолчанию .
Чтобы связать все существующие темы с исходным административным пользователем ll_admin, я ввел в точке  идентификатор пользователя 1. Вы можете использовать идентификатор любого из созданных пользователей; он не обязан быть суперпользователем. Django проводит миграцию базы данных, используя это значение, и создает файл миграции 0003_topic_owner.py, добавляющий поле owner в модель Topic.
Теперь можно провести миграцию. Введите следующую команду в активной виртуальной среде:
(ll_env)learning_log$ python manage.py migrate
Operations to perform:
Apply all migrations: admin, auth, contenttypes, learning_logs, sessions
Running migrations:
❶ Applying learning_logs.0003_topic_owner... OK
(ll_env)learning_log$
Django применяет новую миграцию с результатом OK .

Чтобы убедиться в том, что миграция сработала так, как и ожидалось, можно воспользоваться интерактивной оболочкой:
❶ >>> from learning_logs.models import Topic
❷ >>> for topic in Topic.objects.all():
... print(topic, topic.owner)
...
Chess ll_admin
Rock Climbing ll_admin
>>>
После импортирования Topic из learning_logs.models  мы перебираем все существующие темы, выводим каждую тему и имя пользователя, которому она принадлежит . Как видите, сейчас каждая тема принадлежит пользователю ll_admin. (Если при выполнении кода произойдет ошибка, попробуйте выйти из оболочки и запустить ее заново.)
ПРИМЕЧАНИЕ Вместо миграции можно просто сбросить содержимое базы данных, но это приведет к потере всех существующих данных. Полезно научиться выполнять миграцию базы данных без нарушения целостности данных пользователей. Если вы хотите начать с новой базы данных, используйте команду python manage.py flush для повторного построения структуры базы данных. Вам придется создать нового суперпользователя, а все данные будут потеряны.

ОГРАНИЧЕНИЕ ДОСТУПА К ТЕМАМ

В настоящее время пользователь, выполнивший вход, будет видеть все темы независимо от того, под какой учетной записью он вошел. Сейчас мы изменим приложение, чтобы каждый пользователь видел только принадлежащие ему темы.
Внесите следующее изменение в функцию topics() в файле views.py:
views.py
...
@login_required
def topics(request):
"""Выводит список тем."""
topics = Topic.objects.filter(owner=request.user).order_by('date_added')
context = {'topics': topics}
return render(request, 'learning_logs/topics.html', context)
...
Если пользователь выполнил вход, в объекте запроса устанавливается атрибут request.user с информацией о пользователе.
Фрагмент кода Topic.objects.filter(owner=request.user) приказывает Django извлечь из базы данных только те объекты
Topic, у которых атрибут owner соответствует текущему пользователю. Так как способ отображения не изменяется,
изменять шаблон для страницы тем вообще не нужно.
Чтобы увидеть, как работает этот способ, выполните вход в качестве пользователя, с которым связаны все существующие темы, и перейдите к странице со списком тем. На ней должны отображаться все темы. Теперь завершите сеанс и войдите снова с другой учетной записью. На этот раз страница должна быть пустой.

ЗАЩИТА ТЕМ ПОЛЬЗОВАТЕЛЯ

Никаких реальных ограничений на доступ к страницам еще не существует, поэтому любой зарегистрированный пользователь может опробовать разные URL (например, http://localhost:8000/topics/1/) и просмотреть страницы тем, которые ему удастся подобрать.
Попробуйте сделать это. После входа с учетной записью суперпользователя скопируйте URL или запишите идентификатор в URL темы, после чего завершите сеанс и войдите снова от имени другого пользователя. Введите URL этой темы. Вам удастся прочитать все записи, хотя сейчас вы вошли под именем другого пользователя.
Чтобы решить эту проблему, мы будем выполнять проверку перед получением запрошенных данных в функции представления topic():
views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
❶ from django.http import Http404
...
@login_required
def topic(request, topic_id):
"""Выводит одну тему и все ее записи."""
topic = Topic.objects.get(id=topic_id)
# Проверка того, что тема принадлежит текущему пользователю.
❷ if topic.owner != request.user:
raise Http404
entries = topic.entry_set.order_by('-date_added')
context = {'topic': topic, 'entries': entries}
return render(request, 'learning_logs/topic.html', context)
...
Код 404 — стандартное сообщение об ошибке, которое возвращается в тех случаях, когда запрошенный ресурс не существует
на сервере. В данном случае мы импортируем исключение Http404 , которое будет выдаваться программой при запросе
пользователем темы, которую ему видеть не положено. Получив запрос темы, перед отображением страницы мы убеждаемся
в том, что пользователь этой темы является текущим пользователем приложения. Если тема не принадлежит текущему
пользователю, выдается исключение Http404 , а Django возвращает страницу с ошибкой 404.
Пока при попытке просмотреть записи другого пользователя вы получите от Django сообщение «Страница не найдена». В главе 20 проект будет настроен так, чтобы пользователь видел полноценную страницу ошибки.

ЗАЩИТА СТРАНИЦЫ EDIT_ENTRY

Страницы edit_entry используют URL-адреса в форме http://localhost:8000/edit_entry/entry_id/, где entry_id — число. Защитим эту страницу, чтобы никто не мог подобрать URL для получения доступа к чужим записям:
views.py
...
@login_required
def edit_entry(request, entry_id):
"""Редактирует существующую запись."""
entry = Entry.objects.get(id=entry_id)
topic = entry.topic
if topic.owner != request.user:
raise Http404
if request.method != 'POST':
...
Программа читает запись и тему, связанную с этой записью. Затем мы проверяем, совпадает ли владелец темы с текущим пользователем; при несовпадении выдается исключение Http404.

СВЯЗЫВАНИЕ НОВЫХ ТЕМ С ТЕКУЩИМ ПОЛЬЗОВАТЕЛЕМ

В настоящее время страница добавления новых тем не совершенна, потому что она не связывает новые темы с конкретным
пользователем.
При попытке добавить новую тему выдается сообщение об ошибке IntegrityError с уточнением NOT NULL constraint failed:
learning_logs_topic.owner_id. Django говорит, что при создании новой темы обязательно должно быть задано
значение поля owner.
Проблема легко решается, потому что мы можем получить доступ к информации текущего пользователя через объект request.
Добавьте следующий код, связывающий новую тему с текущим пользователем:

views.py
...
@login_required
def new_topic(request):
"""Определяет новую тему."""
if request.method != 'POST':
# Данные не отправлялись; создается пустая форма.
form = TopicForm()
else:
# Отправлены данные POST; обработать данные.
form = TopicForm(data=request.POST)
if form.is_valid():
❶ new_topic = form.save(commit=False)
❷ new_topic.owner = request.user
❸ new_topic.save()
return redirect('learning_logs:topics')
# Вывести пустую или недействительную форму.
context = {'form': form}
return render(request, 'learning_logs/new_topic.html', context)
...
При первом вызове form.save() передается аргумент commit=False, потому что новая тема должна быть изменена перед
сохранением в базе данных . Атрибуту owner новой темы присваивается текущий пользователь .
Наконец, мы вызываем save() для только что определенного экземпляра темы . Теперь тема содержит все обязательные
данные и ее сохранение пройдет успешно.
Вы сможете добавить сколько угодно новых тем для любого количества разных пользователей.
Каждому пользователю будут доступны только его собственные данные, какие бы операции он ни пытался выполнять —
просмотр данных, ввод новых или изменение существующих данных.

ИТОГИ

В этой главе вы научились использовать формы для создания новых тем и записей,
а также редактирования существующих данных.
Далее мы перешли к реализации системы учетных записей.
Вы предоставили существующим пользователям возможность начинать и завершать сеанс работы с приложением,
а также научились использовать класс Django UserCreationForm для создания новых учетных записей.
После создания простой системы аутентификации и регистрации пользователей вы ограничили доступ пользователей к
некоторым страницам; для этого использовался декоратор @login_required. Затем данные были связаны с конкретными
пользователями при помощи отношения внешнего ключа. Вы также узнали, как выполнить миграцию базы данных,
когда миграция требует ввести данные по умолчанию.
В последней части главы вы узнали, как ограничить состав данных, просматриваемых пользователем,
с использованием функций представления.
Для чтения соответствующих данных использовался метод filter(),
а владелец запрашиваемых данных сравнивался с текущим пользователем.
Не всегда бывает сразу понятно, какие данные должны быть доступны всем пользователям, а какие данные следует защищать,
но этот навык приходит с практикой.
Решения, принятые нами в этой главе для защиты данных пользователей, наглядно показывают, почему при построении
проекта желательно работать в команде: если кто-то просматривает код вашего проекта, это повышает вероятность
выявления плохо защищенных областей.
К настоящему моменту мы построили полностью функциональный проект, работающий на локальной машине.
В последней главе мы доработаем оформление приложения Learning Log, чтобы оно выглядело более привлекательно.
Также проект будет развернут на сервере, чтобы любой пользователь с доступом к интернету мог зарегистрироваться
и создать учетную запись.

ОФОРМЛЕНИЕ И РАЗВЕРТЫВАНИЕ ПРИЛОЖЕНИЯ

Приложение Learning Log уже вполне работоспособно, но оно не имеет стилевого оформления и работает только на локальной машине. В этой главе мы определим для проекта простое, но профессиональное оформление, а затем развернем его на сервере, чтобы любой желающий мог создать учетную запись.
Для стилевого оформления будет использоваться библиотека Bootstrap — набор инструментов для оформления веб-приложений, с которыми они будут выглядеть профессионально на любых современных устройствах, от большого монитора с плоским экраном до смартфона. Для этого мы воспользуемся приложением django-bootstrap4, а вы заодно потренируетесь в использовании приложений, созданных другими разработчиками Django.
Для развертывания Learning Log будет использоваться Heroku — сайт, позволяющий загрузить ваш проект на один из его серверов, чтобы сделать его доступным для любого пользователя с подключением к интернету. Также мы начнем пользоваться системой контроля версий Git для отслеживания изменений в проекте.
Когда работа с Learning Log будет завершена, вы будете уметь разрабатывать простые веб-приложения, придавать им качественный внешний вид и развертывать их на работающих серверах. Также по мере накопления опыта вы научитесь пользоваться ресурсами с материалами более высокого уровня.

ОФОРМЛЕНИЕ ПРИЛОЖЕНИЯ LEARNING LOG

До сих пор мы намеренно игнорировали оформление приложения, чтобы сосредоточиться на его функциональности. И это вполне разумный подход к разработке, потому что приложение приносит пользу только в том случае, если оно работает. Конечно, когда приложение начинает работать, оформление выходит на первый план, чтобы пользователи захотели работать с ним.
В этом разделе я кратко опишу приложение django-bootstrap4 и покажу, как интегрировать его в проект и подготовить к развертыванию.

ПРИЛОЖЕНИЕ DJANGO-BOOTSTRAP4

Для интеграции Bootstrap в наш проект будет использоваться приложение django-bootstrap4. Это приложение загружает необходимые файлы Bootstrap, размещает их в правильных каталогах проекта и предоставляет доступ к стилевым директивам в шаблонах проекта.
Чтобы установить django-bootstrap4, введите следующую команду в активной виртуальной среде:
(ll_env)learning_log$ pip install django-bootstrap4
...
Successfully installed django-bootstrap4-0.0.7
Затем необходимо добавить следующий код для включения django-bootstrap4 в список INSTALLED_APPS в файле settings.py:
settings.py
...
INSTALLED_APPS = [
# Мои приложения
'learning_logs',
'users',
# Сторонние приложения
'bootstrap4',
# Приложения django по умолчанию.
'django.contrib.admin',
...
Создайте новую секцию для приложений, созданных другими разработчиками, и включите в нее запись 'bootstrap4'. Проследите за тем, чтобы секция располагалась после секции # Мои приложения, но перед секцией, содержащей приложения Django по умолчанию.
Использование Bootstrap для оформления Learning Log
По сути, Bootstrap представляет собой большой набор инструментов стилевого оформления. Также библиотека содержит ряд шаблонов, которые можно применить к проекту для формирования общего стиля. Пользоваться этими шаблонами намного проще, чем отдельными инструментами оформления. Чтобы просмотреть шаблоны, предоставляемые Bootstrap, перейдите по ссылке http://getbootstrap.com/, щелкните на ссылке Examples и найдите раздел Navbars. Мы воспользуемся шаблоном Navbar static, который предоставляет простую панель навигации и контейнер для содержимого страницы.
На рис. 20.1 показано, как будет выглядеть домашняя страница после применения шаблона Bootstrap к base.html и незначительного изменения index.html.

ИЗМЕНЕНИЕ BASE.HTML

Шаблон base.html необходимо изменить так, чтобы в нем был задействован шаблон Bootstrap. Новая версия base.html будет представлена в несколько этапов.
Определение заголовков HTML
Первое изменение в base.html: заголовки HTML определяются в файле, чтобы при открытии страницы Learning Log в строке заголовка браузера выводилось имя сайта. Также будут добавлены некоторые требования для использования Bootstrap в шаблонах. Удалите все содержимое base.html и замените его следующим кодом:
base.html
❶ {% load bootstrap4 %}
❷ <!doctype html>
❸ <html lang="en">
❹ <head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1,
shrink-to-fit=no">
❺ <title>Learning Log</title>
❻ {% bootstrap_css %}
{% bootstrap_javascript jquery='full' %}
❼ </head>

В точке  загружается коллекция шаблонных тегов из django-bootstrap4.
Затем файл объявляется как документ HTML , написанный на английском языке .
Файл HTML состоит из двух основных частей, заголовка и тела; заголовок файла начинается в точке .
Заголовок файла HTML не содержит контента: он всего лишь передает браузеру информацию,
необходимую для правильного отображения страницы.
В точке  включается элемент title страницы;
его содержимое будет выводиться в строке заголовка браузера при открытии Learning Log.
В точке  используется один из шаблонных тегов django-bootstrap4,
который приказывает Django включить все стилевые файлы Bootstrap.
Следующий тег активизирует все интерактивное поведение, которое может использоваться на странице,
например раздвижные навигационные панели.
В точке  располагается закрывающий тег </head>.

ОПРЕДЕЛЕНИЕ НАВИГАЦИОННОЙ ПАНЕЛИ

Код, определяющий навигационную панель в верхней части страницы, получается довольно длинным, потому что он должен хорошо работать как на узких экранах смартфонов, так и на широких экранах мониторов настольных компьютеров. Мы рассмотрим код навигационной панели по частям.
Первая часть навигационной панели выглядит так:
base.html
...
</head>
❶ <body>
❷ <nav class="navbar navbar-expand-md navbar-light bg-light mb-4 border">
❸ <a class="navbar-brand" href="{% url 'learning_logs:index'%}">
Learning Log</a>
❹ <button class="navbar-toggler" type="button" data-toggle="collapse"
data-target="#navbarCollapse" aria-controls="navbarCollapse"
aria-expanded="false" aria-label="Toggle navigation">
<span class="navbar-toggler-icon"></span></button>
Первый элемент — открывающий тег <body> . Тело файла HTML содержит контент,
который будет виден пользователям на странице.
В точке  элемент <nav> обозначает раздел навигационных ссылок на странице.
Весь контент внутри этого элемента оформляется по правилам Bootstrap, определяемым селекторами navbar,
navbar-expand-md и другим перечисленным здесь.
Селектор определяет, к каким элементам страницы должно применяться стилевое правило.
Селекторы navbar-light и bg-light оформляют навигационную панель темой со светлым фоном.
Сокращение mb в mb-4 происходит от «margin-bottom», то есть «нижнее поле»; этот селектор гарантирует,
что между навигационной панелью и остальным контентом страницы остается свободное место.
Селектор border создает тонкую рамку вокруг светлого фона, чтобы немного отделить его от остального контента страницы.
В точке  задается имя проекта, которое выводится у левого края навигационной панели, и создается ссылка на домашнюю страницу; она будет отображаться на каждой странице проекта. Селектор navbar-brand оформляет эту ссылку так, чтобы она выделялась на фоне остальных ссылок; это оформление становится одной из составляющих фирменной символики сайта.
В точке  шаблон определяет кнопку, которая будет отображаться, если ширины окна браузера не хватает для горизонтального отображения всей навигационной панели. Когда пользователь нажимает кнопку, навигационные элементы выводятся в раскрывающемся списке. Атрибут collapse сворачивает навигационную панель при уменьшении размеров окна браузера и при отображении сайта на мобильных устройствах с малыми экранами.
Следующая часть кода, определяющего навигационную панель:
base.html
...
<span class="navbar-toggler-icon"></span></button>
❶ <div class="collapse navbar-collapse" id="navbarCollapse">
❷ <ul class="navbar-nav mr-auto">
❸ <li class="nav-item">
<a class="nav-link" href="{% url 'learning_logs:topics'%}">
Topics</a></li>
</ul>
В точке  открывается новая секция навигационной панели. В процессе построения веб-страницы разработчик делит ее на секции и определяет стили и правила поведения, применяемые к текущей секции. Все стилевые директивы и правила поведения, определяемые в открывающем теге div, продолжают действовать до следующего, закрывающего тега div, который записывается в виде </div>. Это начало той части навигационной панели, которая будет сворачиваться на узких экранах и окнах.
В точке  определяется новый набор ссылок. Bootstrap определяет навигационные элементы как элементы неупорядоченного списка со стилевым оформлением, с которым они совершенно не похожи на список. Каждая ссылка или элемент, который должен отображаться на панели, включается как элемент одного из этих списков. В данном случае единственным элементом списка является ссылка на страницу Topics .
Следующая часть навигационной панели:
base.html
...
</ul>
❶ <ul class="navbar-nav ml-auto">
❷ {% if user.is_authenticated %}
<li class="nav-item">
❸ <span class="navbar-text"}">Hello, {{ user.username }}.</span>
</li>
<li class="nav-item">
<a class="nav-link" href="{% url 'users:logout' %}">Log out</a>
</li>
{% else %}
<li class="nav-item">
<a class="nav-link" href="{% url 'users:register' %}">Register</a>
</li>
<li class="nav-item">
<a class="nav-link" href="{% url 'users:login' %}">Log in</a></li>
{% endif %}
</ul>
❹ </div>
</nav>
В точке  новый набор ссылок начинается при помощи другого открывающего тега <ul>. На странице можно создать столько групп ссылок, сколько вам понадобится. Эта группа содержит ссылки, связанные со входом и регистрацией, расположенные в правой части навигационной панели. Имя селектора ml-auto означает «margin-left-automatic», то есть «автоматическое левое поле»; этот селектор анализирует другие элементы на навигационной панели и определяет величину левого поля, которое сдвигает эту группу ссылок к правому краю экрана.
Блок if в точке  уже использовался ранее для вывода сообщений для пользователей в зависимости от того, выполнили они вход или нет. На этот раз блок стал немного длиннее, потому что некоторые стилевые правила находятся внутри условных тегов. В точке  расположен элемент <span>. Элемент span оформляет фрагменты текста или элементы страницы, которые являются частью более длинной строки. Если элементы div создают собственный раздел страницы, элементы span непрерывно располагаются внутри большего раздела. На первый взгляд такая структура кажется запутанной, потому что многие страницы содержат элементы div с большой вложенностью. Здесь элемент span используется для оформления текста на навигационной панели — например, имени пользователя, выполнившего вход. Эта информация должна отличаться по внешнему виду от ссылок, чтобы у пользователей не возникало желания щелкать на них.
В точке  закрывается элемент div с частями навигационной панели, которые сворачиваются на узких экранах, а в конце секции закрывается навигационная панель в целом. Если вы захотите добавить больше ссылок на навигационную панель, включите другой элемент <li> в любую из групп <ul>, определенных на навигационной панели; используйте стилевые директивы, идентичные приведенным выше.
Работа с файлом base.html еще не закончена. Необходимо определить два блока, которые могут использоваться отдельными страницами для размещения контента, относящегося к этим страницам.

ОПРЕДЕЛЕНИЕ ОСНОВНОГО РАЗДЕЛА СТРАНИЦЫ

Оставшаяся часть base.html содержит основной контент страницы:

base.html
...
</nav>
❶ <main role="main" class="container">
❷ <div class="pb-2 mb-2 border-bottom">
{% block page_header %}{% endblock page_header %}
</div>
❸ <div>
{% block content %}{% endblock content %}
</div>
</main>
</body>
</html>
В точке  открывается тег <main>. Элемент main используется для основного контента в теле страницы. В данном случае назначается селектор container, что является простым способом группировки элементов на странице. В этот контейнер будут включены два элемента div.
Первый элемент div  содержит блок page_header. Мы будем использовать этот блок для отображения заголовка большинства страниц. Чтобы секция выделялась на фоне других частей страницы, мы разместим отступы под заголовком. Отступ (padding) представляет собой пространство между контентом элемента и его границей. Селектор pb-2 — директива Bootstrap, создающая отступы умеренной величины в нижней части оформляемого элемента. Полем (margin) называется пространство между границей элемента и другими элементами страницы. В нашем приложении граница нужна только в нижней части страницы, поэтому мы используем селектор border-bottom, создающий тонкую границу в нижней части блока page_header.
В точке  определяется еще один элемент div, содержащий блок content. К этому блоку не применяется никакой конкретный стиль, поэтому контент любой страницы можно оформить так, как вы считаете нужным для этой страницы. Файл base. html завершается закрывающими тегами для элементов main, body и html.
Загрузив домашнюю страницу Learning Log в браузере, вы увидите профессиональную навигационную панель, изображенную на рис. 20.1. Попробуйте изменить размеры окна, заметно уменьшив его ширину; навигационная панель должна превратиться в кнопку. Щелкните на кнопке, и все ссылки появятся в раскрывающемся списке.
Оформление домашней страницы с использованием табло
Изменим домашнюю страницу при помощи нового блока header и другого элемента Bootstrap, так называемого джамботронома — большого блока, который выдается на общем фоне страницы и может содержать любую информацию на ваше усмотре

ние. Обычно этот элемент используется на домашних страницах для размещения краткого описания проекта.
Обновленный файл index.html выглядит так:
index.html
{% extends "learning_logs/base.html" %}
❶ {% block page_header %}
❷ <div class='jumbotron'>
❸ <h1 class="display-3">Track your learning.</h1>
❹ <p class="lead">Make your own Learning Log, and keep a list of the
topics you're learning about. Whenever you learn something new
about a topic, make an entry summarizing what you've learned.</p>
❺ <a class="btn btn-lg btn-primary" href="{% url 'users:register' %}"
role="button">Register &raquo;</a>
</div>
❻ {% endblock page_header %}
В точке  мы сообщаем Django о том, что далее следует определение содержимого блока page_header. Элемент jumbotron  представляет собой обычный элемент div, к которому применяется набор стилевых директив. Селектор jumbotron применяет эту группу стилевых директив из библиотеки Bootstrap к элементу.
Внутри элемента jumbotron содержатся три элемента. Первый — короткое сообщение Track your learning, которое дает новым посетителям представление о том, что делает Learning Log. Класс h1 является заголовком первого уровня, а с селектором display-3 заголовок становится более тонким и высоким . В точке  включается более длинное сообщение с дополнительной информацией о том, что пользователь может сделать со своим дневником.
Вместо простой текстовой ссылки мы создаем кнопку , которая предлагает пользователю зарегистрировать свою учетную запись Learning Log. Это та же ссылка, что и в заголовке, но кнопка выделяется на фоне страницы и показывает пользователю, что необходимо сделать для того, чтобы приступить к работе над проектом. В результате применения селекторов получается крупная кнопка, представляющая желаемое действие. Код &raquo; является сущностью HTML, представляющей две правые угловые скобки (>>). В точке  блок page_header закрывается. Контент на эту страницу добавляться не будет, поэтому определять блок content на этой странице не нужно.
Теперь страница выглядит так, как на рис. 20.1. Она смотрится намного лучше по сравнению с проектом без применения оформления.

ОФОРМЛЕНИЕ СТРАНИЦЫ ВХОДА

Мы усовершенствовали внешний вид страницы входа, но формы входа изменения пока не коснулись. Приведем внешний вид формы в соответствие с остальными элементами страницы:
login.html
{% extends "learning_logs/base.html" %}
❶ {% load bootstrap4 %}
❷ {% block page_header %}
<h2>Log in to your account.</h2>
{% endblock page_header %}
{% block content %}
❸ <form method="post" action="{% url 'users:login' %}" class="form">
{% csrf_token %}
❹ {% bootstrap_form form %}
❺ {% buttons %}
<button name="submit" class="btn btn-primary">Log in</button>
{% endbuttons %}
<input type="hidden" name="next"
value="{% url 'learning_logs:index' %}" />
</form>
{% endblock content %}
В точке  в шаблон загружаются шаблонные теги bootstrap4. В точке  определяется блок page_header, который описывает, для чего нужна страница. Обратите внимание: блок {% if form.errors %} удален из шаблона; django-bootstrap4 управляет ошибками формы автоматически.
В точке  добавляется атрибут class="form", после чего при отображении формы  используется шаблонный тег {% bootstrap_form %}; он заменяет тег {{ form.as_p }}, используемый в главе 19. Шаблонный тег {% booststrap_form %} вставляет правила в стиле Bootstrap в отдельные элементы формы при ее построении. В точ-
ке  открывается шаблонный тег bootstrap4 {% buttons %}, который добавляет стилевое оформление Bootstrap к кнопкам.
На рис. 20.2 показана форма входа так, как она выглядит сейчас. Страница стала намного чище, ее оформление последовательно, а предназначение предельно ясно. Попробуйте выполнить вход с неверным именем пользователя или паролем; вы увидите, что даже сообщения об ошибках следуют тому же стилю оформления и хорошо интегрируются с сайтом в целом.
Оформление страницы со списком тем
А теперь позаботимся о том, чтобы страницы для просмотра информации также были выдержаны в том же стиле. Начнем со страницы со списком тем:
topics.html
{% extends "learning_logs/base.html" %}
❶ {% block page_header %}
<h1>Topics</h1>
{% endblock page_header %}
{% block content %}
<ul>
{% for topic in topics %}
❷ <li><h3>
<a href="{% url 'learning_logs:topic' topic.id %}">{{ topic }}</a>
</h3></li>
{% empty %}
<li><h3>No topics have been added yet.</h3></li>
{% endfor %}
</ul>
❸ <h3><a href="{% url 'learning_logs:new_topic' %}">Add new topic</h3>
{% endblock content %}
Тег {% load bootstrap4 %} не нужен, потому что в этом файле не используются никакие шаблонные теги bootstrap4. Заголовок Topics перемещается в блок page_header, и вместо простого абзацного тега ему назначается оформление заголовка . Каждая тема оформляется как элемент <h3>, чтобы она выводилась чуть более крупным шрифтом на странице ; то же самое делается со ссылкой добавления новой темы .

ОФОРМЛЕНИЕ ЗАПИСЕЙ НА СТРАНИЦЕ ТЕМЫ

Страница темы содержит больше контента, чем большинство страниц, поэтому над ней придется потрудиться. Чтобы записи визуально выделялись, мы воспользуемся панелями Bootstrap. Панель (card) представляет собой элемент div с заранее определенным гибким стилем и идеально подходит для отображения записей темы:
464 Глава 20 • Оформление и развертывание приложения
topic.html
{% extends 'learning_logs/base.html' %}
❶ {% block page_header %}
<h3>{{ topic }}</h3>
{% endblock page_header %}
{% block content %}
<p>
<a href="{% url 'learning_logs:new_entry' topic.id %}">Add new entry</a>
</p>
{% for entry in entries %}
❷ <div class="card mb-3">
❸ <h4 class="card-header">
{{ entry.date_added|date:'M d, Y H:i' }}
❹ <small><a href="{% url 'learning_logs:edit_entry' entry.id %}">
edit entry</a></small>
</h4>
❺ <div class="card-body">
{{ entry.text|linebreaks }}
</div>
</div>
{% empty %}
<p>There are no entries for this topic yet.</p>
{% endfor %}
{% endblock content %}
Сначала тема размещается в блоке page_header . Затем удаляется структура неупорядоченного списка, использовавшаяся ранее в этом шаблоне. Вместо того чтобы превращать каждую запись в элемент списка, мы создаем в точке  элемент с селектором card. Он имеет два вложенных элемента: первый предназначен для хранения временной метки и ссылки для редактирования, а второй — для хранения тела записи.
Первый элемент в панели представляет собой заголовок — элемент <h4> с селектором card-header . Заголовок панели содержит дату создания записи и ссылку для ее редактирования. Ссылка edit_entry заключается в тег <small>, чтобы она была чуть меньше временной метки . Второй элемент представляет собой div с селектором card-body , который размещает текст записи в простом поле на карте. Обратите внимание: код Django для включения информации на страницу не изменился; изменились только элементы, влияющие на внешний вид страницы.
На рис. 20.3 изображена страница темы с новым оформлением. Функциональность приложения Learning Log не изменилась, но приложение выглядит более привлекательно и заманчиво для пользователя.

ПРИМЕЧАНИЕ

Если вы хотите использовать другой шаблон Bootstrap, действуйте в той же последовательности, которая уже использовалась в этой главе. Скопируйте шаблон в base.html и измените элементы, содержащие контент, чтобы шаблон отображал информацию вашего проекта. Затем воспользуйтесь средствами индивидуального стилевого оформления Bootstrap для оформления содержимого каждой страницы.

РАЗВЕРТЫВАНИЕ LEARNING LOG

После того как проекту был придан профессиональный вид, мы развернем его на реальном сервере, чтобы любой пользователь с подключением к интернету мог работать с приложением. Мы воспользуемся Heroku — веб-платформой, позволяющей управлять развертыванием веб-приложений.
Создание учетной записи Heroku
Чтобы создать учетную запись, откройте сайт https://heroku.com/ и щелкните на одной из регистрационных ссылок. Учетные записи создаются бесплатно, и Heroku предоставляет бесплатный уровень для тестирования проектов в реальных условиях.
ПРИМЕЧАНИЕ На бесплатном уровне Heroku существуют свои ограничения (например, количество приложений, которые можно развернуть, и частота посещения приложения пользователями). Впрочем, эти ограничения достаточно либеральны, чтобы вы могли потренироваться в развертывании приложений без каких-либо затрат.
